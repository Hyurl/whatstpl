{"version":3,"sources":["webpack://whatstpl/webpack/universalModuleDefinition","webpack://whatstpl/webpack/bootstrap","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/errors.js","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/index.js","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/parser.js","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/utils.js","webpack://whatstpl/./src/index.ts","webpack://whatstpl/./src/module.ts","webpack://whatstpl/external \"fs\""],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;AAGA;AACA;;;;;;;;;;;;;ACzEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,iC;;;;;;;;;;;;ACRA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;AC1ZA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,2IAA2I;AAC9L,YAAY;AACZ;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;;;ACxFA,wHAY0B;AAC1B,wEAAgD;AAEhD,IAAI,EAAE,GAEF,IAAI,CAAC;AAET,IAAI,CAAC,4BAAS,EAAE;IACZ,EAAE,GAAG,mBAAO,CAAC,cAAI,CAAC,CAAC;CACtB;AAmBY,qBAAa,GAAkB;IACxC,QAAQ,EAAE,MAAM;IAChB,KAAK,EAAE,KAAK;IACZ,cAAc,EAAE,KAAK;IACrB,OAAO,EAAE,IAAI;CAChB;AAED;IAaI,YAAY,QAAQ,GAAG,EAAE,EAAE,UAAe,MAAM;QARxC,gBAAW,GAAW,CAAC,CAAC;QACxB,wBAAmB,GAAW,CAAC,CAAC;QAChC,YAAO,GAA4C,EAAE,CAAC;QAO1D,IAAI,QAAQ;YACR,IAAI,CAAC,QAAQ,GAAG,6BAAU,CAAC,QAAQ,CAAC,CAAC;;YAErC,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAC;QAEhC,IAAI,OAAO,OAAO,IAAI,QAAQ;YAC1B,OAAO,GAAG,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC;QAEpC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,qBAAa,EAAE,OAAO,CAAC,CAAC;IAC7D,CAAC;IAED,2CAA2C;IACrC,MAAM,CAAC,GAAW,EAAE,SAAoB,EAAE;;YAC5C,IAAI,MAAM,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YACrC,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC;QAC1B,CAAC;KAAA;IAKD,MAAM,CAAO,UAAU,CAAC,QAAgB,EAAE,SAAoB,IAAI,EAAE,OAAO,GAAG,IAAI;;YAC9E,IAAI,MAAM,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YACvD,OAAO,MAAM,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC;QAChC,CAAC;KAAA;IAED,4CAA4C;IACtC,OAAO,CAAC,GAAW;;YACrB,0DAA0D;YAC1D,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;gBACrD,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aACxC;YAED,IAAI,MAAM,GAAG,IAAI,yBAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAClC,IAAI,GAAS,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,EAC9B,OAAO,GAAW,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YAEpD,sEAAsE;YACtE,mEAAmE;YACnE,6CAA6C;YAC7C,IAAI,MAAM,GAAa,CAAC,MAAM,GAAG,EAAE,EAAE,EAAE;gBACnC,IAAI;oBACA,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC;iBACzD;gBAAC,OAAO,GAAG,EAAE,EAAE,kCAAkC;oBAC9C,MAAM,qBAAY,CAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;iBAC1C;YACL,CAAC,CAAC;YAEF,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK;gBAClB,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC;YAE3C,OAAO,MAAM,CAAC;QAClB,CAAC;KAAA;IAKD,MAAM,CAAO,WAAW,CAAC,QAAgB,EAAE,UAAe,IAAI;;YAC1D,QAAQ,GAAG,6BAAU,CAAC,QAAQ,CAAC,CAAC;YAEhC,0DAA0D;YAC1D,IAAI,OAAO,IAAI,OAAO,CAAC,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE;gBACtD,OAAO,QAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;aACnC;YAED,IAAI,GAAG,GAAa,IAAI,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,EAC3C,IAAI,GAAG,MAAM,GAAG,CAAC,YAAY,EAAE,CAAC;YAEpC,OAAO,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC7B,CAAC;KAAA;IAED,iDAAiD;IACvC,YAAY;QAClB,IAAI,CAAC,4BAAS,EAAE;YACZ,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACnC,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE;oBAC5D,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBACtC,CAAC,CAAC,CAAC;YACP,CAAC,CAAC,CAAC;SACN;aAAM;YACH,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACnC,IAAI,GAAG,GAAG,IAAI,cAAc,EAAE,CAAC;gBAC/B,GAAG,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC;gBACnC,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;gBACrC,GAAG,CAAC,MAAM,GAAG,GAAG,EAAE;oBACd,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;gBAC9B,CAAC,CAAC;gBACF,GAAG,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,GAAG,GAAG,CAAC,SAAS,GAAG,GAAG,EAAE;oBAC7C,MAAM,CAAC,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC,CAAC;gBACvD,CAAC,CAAC;gBACF,GAAG,CAAC,IAAI,EAAE,CAAC;YACf,CAAC,CAAC,CAAC;SACN;IACL,CAAC;IAED,kEAAkE;IACxD,UAAU,CAAC,QAAgB;QACjC,IAAI,CAAC,4BAAS,CAAC,QAAQ,CAAC,EAAE;YACtB,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,IAAI,WAAW;gBACnD,CAAC,CAAC,0BAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;gBACxB,CAAC,CAAC,yBAAM,EAAE,CAAC;YAEf,QAAQ,GAAG,gCAAa,CAAC,GAAG,GAAG,4BAAS,GAAG,QAAQ,CAAC,CAAC;SACxD;QAED,oEAAoE;QACpE,IAAI,CAAC,0BAAO,CAAC,QAAQ,CAAC,EAAE;YACpB,QAAQ,IAAI,0BAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SACtC;QAED,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED,uEAAuE;IAC/D,YAAY,CAAC,MAAc,EAAE,IAAU;QAC3C,IAAI,CAAC,WAAW,IAAI,CAAC,CAAC;QACtB,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC;IAC/D,CAAC;IAED,2DAA2D;IACjD,QAAQ,CAAC,MAAc,EAAE,QAAgB,EAAE,KAAa,EAAE,IAAU,EAAE,UAAU,GAAG,IAAI;QAC7F,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,MAAM,GAAG,QAAQ,GAAG,KAAK,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QACzE,uEAAuE;QACvE,4BAA4B;QAC5B,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC;IAC/C,CAAC;IAED,4CAA4C;IAC5B,YAAY,CAAC,SAAiB,IAAI;;YAC9C,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,eAAM,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;gBACnD,OAAO,eAAM,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;aACtC;YAED,IAAI,GAAG,GAAG,MAAM,IAAI,CAAC,YAAY,EAAE,EAC/B,MAAM,GAAG,IAAI,yBAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAClC,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAE7B,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAC3C,CAAC;KAAA;IAED,0EAA0E;IAC5D,YAAY,CAAC,IAAU,EAAE,SAAiB,IAAI;;YACxD,IAAI,OAAO,GAAG,IAAI,eAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAExC,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC;YAEtB,MAAM,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;YAErC,gEAAgE;YAChE,sEAAsE;YACtE,iCAAiC;YACjC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;gBACrB,KAAK,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,IAAI,CAAC,OAAO,EAAE;oBACzC,IAAI,CAAC,mBAAmB,IAAI,CAAC,CAAC;oBAE9B,IAAI,QAAQ,GAAG,WAAW,GAAG,IAAI,CAAC,mBAAmB,CAAC;oBACtD,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;oBAE3C,gEAAgE;oBAChE,oDAAoD;oBACpD,IAAI,CAAC,QAAQ,CACT,SAAS,QAAQ,KAAK,EACtB,YAAY,QAAQ,4BAA4B,EAChD,GAAG,EACH,IAAI,CACP,CAAC;oBACF,IAAI,CAAC,QAAQ,CAAC,iBAAiB,EAAE,GAAG,QAAQ,UAAU,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;iBACtE;aACJ;YAED,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC;YACxB,eAAM,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC,CAAC,oBAAoB;YAC3D,eAAM,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,wBAAwB;YAE9E,OAAO,OAAO,CAAC;QACnB,CAAC;KAAA;IAED,6DAA6D;IAC/C,mBAAmB,CAAC,MAAY,EAAE,MAAM,GAAG,EAAE;;YACvD,IAAI,QAAQ,GAAG,GAAG,CAAC;YAEnB,KAAK,IAAI,IAAI,IAAY,MAAM,CAAC,QAAQ,EAAE;gBACtC,IAAI,IAAI,CAAC,IAAI,IAAI,MAAM;uBAChB,CAAC,IAAI,CAAC,IAAI,IAAI,SAAS,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE;oBAC7D,IAAI,QAAQ,GAAY,IAAI,CAAC,QAAS,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC;yBACvD,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;oBAE1B,IAAI,CAAC,QAAQ,CACT,MAAM,GAAG,mBAAmB,EAC5B,QAAQ,EACR,IAAI,EACJ,IAAI,CACP,CAAC;iBACL;qBAAM,IAAI,IAAI,CAAC,IAAI,IAAI,KAAK,EAAE;oBAC3B,IAAI,IAAI,CAAC,GAAG,IAAI,GAAG,EAAE,EAAE,eAAe;wBAClC,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAU,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;qBAC3D;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,GAAG,EAAE,EAAE,eAAe;wBACzC,IAAI,CAAC,QAAQ,CACT,MAAM,GAAG,kBAAkB,EACnB,IAAI,CAAC,QAAQ,EACrB,GAAG,EACH,IAAI,CACP,CAAC;qBACL;yBAAM,EAAE,eAAe;wBACpB,IAAI,CAAC,QAAQ,CACT,MAAM,GAAG,2BAA2B,EAC5B,IAAI,CAAC,QAAQ,EACrB,IAAI,EACJ,IAAI,CACP,CAAC;qBACL;iBACJ;qBAAM,IAAI,IAAI,CAAC,IAAI,IAAI,SAAS,EAAE,EAAE,sCAAsC;oBACvE,yBAAyB;oBACzB,uDAAuD;oBAEvD,iBAAiB;oBACjB,kCAAkC;oBAClC,IAAI;oBAEJ,IAAI,QAAQ,GAAW,QAAQ;wBAC3B,CAAC,CAAU,IAAI,CAAC,QAAS,CAAC,SAAS,CAAC,QAAQ,CAAC;wBAC7C,CAAC,CAAS,IAAI,CAAC,QAAQ,CAAC;oBAE5B,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;iBACjE;qBAAM,IAAI,IAAI,CAAC,IAAI,IAAI,OAAO,EAAE;oBAC7B,IAAI,IAAI,CAAC,GAAG,IAAI,QAAQ,EAAE,EAAE,YAAY;wBACpC,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;qBACzC;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,QAAQ,EAAE,EAAE,YAAY;wBAC3C,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;qBACzC;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,OAAO,EAAE,EAAE,kBAAkB;wBAChD,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;qBACxC;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,EAAE,EAAE,YAAY;wBACvC,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;qBACrC;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,SAAS,EAAE,EAAE,sBAAsB;wBACtD,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;qBACtD;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,MAAM,EAAE,EAAE,gBAAgB;wBAC7C,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;qBACpD;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,QAAQ,EAAE,EAAE,oBAAoB;wBACnD,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;qBACzC;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,MAAM,EAAE,EAAE,gBAAgB;wBAC7C,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;qBACvC;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,SAAS,EAAE,EAAE,sBAAsB;wBACtD,MAAM,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;qBAC1C;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,KAAK,EAAE,EAAE,cAAc;wBAC1C,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;qBACtC;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,OAAO,EAAE,EAAE,kBAAkB;wBAChD,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;qBACxC;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,EAAE,EAAE,YAAY;wBACvC,MAAM,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;qBAC1C;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,UAAU,IAAI,IAAI,CAAC,GAAG,IAAI,OAAO,EAAE;wBACtD,2BAA2B;wBAC3B,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;qBAC9C;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,QAAQ,EAAE,EAAE,oBAAoB;wBACnD,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;qBACzC;yBAAM,IAAI,IAAI,CAAC,GAAG,IAAI,QAAQ,EAAE,EAAE,oBAAoB;wBACnD,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;wBAC5B,IAAI,aAAa,GAAG,CAAC,KAAK,CAAC,MAAM;+BAC1B,KAAK,CAAC,MAAM,CAAC,KAAK,IAAI,yBAAM,CAAC,UAAU,CAAC;wBAE/C,IAAI,aAAa,EAAE,EAAE,0BAA0B;4BAC3C,IAAI,QAAQ,GAAG,SAAS,CAAC;4BAEzB,qBAAqB;4BACrB,KAAK,IAAI,IAAI,IAAI,KAAK,EAAE;gCACpB,QAAQ,IAAI,IAAI,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,GAAG,CAAC;6BACjD;4BAED,QAAQ,IAAI,MAAM,CAAC;4BACnB,IAAI,CAAC,QAAQ,CACT,MAAM,GAAG,mBAAmB,EAC5B,QAAQ,EACR,IAAI,EACJ,IAAI,CACP,CAAC;yBACL;wBAED,iDAAiD;wBACjD,MAAM,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;wBAEtD,IAAI,aAAa,EAAE;4BACf,IAAI,CAAC,QAAQ,CACT,MAAM,GAAG,mBAAmB,EAC5B,cAAc,EACd,IAAI,EACJ,IAAI,CACP,CAAC;yBACL;qBACJ;yBAAM,EAAE,2BAA2B;wBAChC,IAAI,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,EAClC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC;wBAE5B,IAAI,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,IAAI,OAAO;4BAC3C,IAAI,GAAG,QAAQ,GAAG,IAAI,CAAC;wBAE3B,IAAI,QAAQ,GAAG,WAAW,CAAC;wBAE3B,yDAAyD;wBACzD,yDAAyD;wBACzD,8BAA8B;wBAC9B,IAAI,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK;4BAC9B,QAAQ,IAAI,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;wBAExC,QAAQ,IAAI,GAAG,CAAC;wBAEhB,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,IAAI,GAAG,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;qBAC3D;iBACJ;aACJ;QACL,CAAC;KAAA;IAED,kCAAkC;IACpB,YAAY,CAAC,IAAU,EAAE,MAAM,GAAG,EAAE;;YAC9C,IAAI,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,EACtD,GAAG,GAAa,IAAU,IAAI,CAAC,WAAY,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;YAExE,MAAM,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAEpC,oEAAoE;YACpE,kEAAkE;YAClE,8CAA8C;YAC9C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC;QAC1C,CAAC;KAAA;IAED,+DAA+D;IACjD,YAAY,CAAC,IAAU,EAAE,MAAM,GAAG,EAAE;;YAC9C,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,EACvB,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,EAC5E,GAAG,GAAa,IAAU,IAAI,CAAC,WAAY,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;YAExE,MAAM,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAEpC,IAAI,CAAC,mBAAmB,IAAI,CAAC,CAAC;YAE9B,IAAI,QAAQ,GAAG,WAAW,GAAG,IAAI,CAAC,mBAAmB,CAAC;YACtD,QAAQ,GAAG,QAAQ,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;YAC3C,IAAI,CAAC,QAAQ,CACT,GAAG,MAAM,SAAS,QAAQ,KAAK,EAC/B,YAAY,QAAQ,cAAc,EAClC,GAAG,EACH,IAAI,CACP,CAAC;YAEF,mEAAmE;YACnE,sBAAsB;YACtB,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE;gBACpC,IAAI,IAAI,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBAElE,KAAK,IAAI,GAAG,IAAI,IAAI,EAAE;oBAClB,mBAAmB;oBACnB,IAAI,IAAI,GAAG,GAAG,CAAC,KAAK,CAAC,UAAU,CAAC,EAC5B,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,EACjB,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,OAAO,CAAC;oBAEjC,IAAI,CAAC,QAAQ,CACT,MAAM,EACN,SAAS,OAAO,MAAM,QAAQ,IAAI,OAAO,EAAE,EAC3C,GAAG,EACH,IAAI,CACP,CAAC;iBACL;aACJ;iBAAM,EAAE,sDAAsD;gBAC3D,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,mBAAmB,QAAQ,UAAU,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;aAC3E;QACL,CAAC;KAAA;IAED,uCAAuC;IACzB,YAAY,CAAC,IAAU,EAAE,MAAM,GAAG,EAAE;;YAC9C,mEAAmE;YACnE,2DAA2D;YAC3D,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,EAAE;gBACxD,IAAI,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;gBAEtD,KAAK,IAAI,CAAC,IAAI,IAAI,EAAE;oBAChB,oBAAoB;oBACpB,IAAI,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,EAChC,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,EACpC,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;oBAE7D,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,QAAQ,OAAO,MAAM,OAAO,EAAE,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;iBACpE;aACJ;QACL,CAAC;KAAA;IAED,yEAAyE;IAC3D,WAAW,CAAC,KAAW,EAAE,MAAM,GAAG,EAAE;;YAC9C,IAAI,KAAK,GAAG,KAAK,CAAC,UAAU,EACxB,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,EAC1C,QAAQ,GAAG,YAAY,IAAI,GAAG,CAAC;YAEnC,6DAA6D;YAC7D,IAAI,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,IAAI,OAAO;gBAC3C,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC;YAEnC,+CAA+C;YAC/C,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK;gBAClC,QAAQ,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC;YAEnC,QAAQ,IAAI,GAAG,CAAC;YAEhB,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;YAE7C,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;YAEvD,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;YAEtC,8DAA8D;YAC9D,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK,IAAI,OAAO;gBAC7C,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,QAAQ,IAAI,MAAM,IAAI,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QACpE,CAAC;KAAA;IAED,wCAAwC;IAC1B,QAAQ,CAAC,KAAW,EAAE,MAAM,GAAG,EAAE;;YAC3C,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,MAAM,EAAE,KAAK,CAAC,UAAU,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YAC/E,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;YACvD,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QAC1C,CAAC;KAAA;IAED,kDAAkD;IACpC,YAAY,CAAC,KAAW,EAAE,MAAM,GAAG,EAAE;;YAC/C,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,aAAa,EAAE,KAAK,CAAC,UAAU,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YACtF,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;QAC3D,CAAC;KAAA;IAED,oBAAoB;IACN,UAAU,CAAC,KAAW,EAAE,MAAM,GAAG,EAAE;;YAC7C,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,UAAU,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;YAClD,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;QAC3D,CAAC;KAAA;IAED,0CAA0C;IAC5B,YAAY,CAAC,KAAW,EAAE,MAAM,GAAG,EAAE;;YAC/C,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,UAAU,EAAE,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YAChF,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;YACvD,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QAC1C,CAAC;KAAA;IAED,kCAAkC;IACpB,UAAU,CAAC,KAAW,EAAE,MAAM,GAAG,EAAE;;YAC7C,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;YACzE,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;YACvD,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QACxD,CAAC;KAAA;IAED,0BAA0B;IACZ,aAAa,CAAC,KAAW,EAAE,MAAM,GAAG,EAAE;;YAChD,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,SAAS,EAAE,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;YAClD,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;YACvD,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QACxD,CAAC;KAAA;IAED,0CAA0C;IAC5B,SAAS,CAAC,KAAW,EAAE,MAAM,GAAG,EAAE;;YAC5C,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,OAAO,EAAE,KAAK,CAAC,UAAU,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YAChF,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;YACvD,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QAC1C,CAAC;KAAA;IAED,8CAA8C;IAChC,WAAW,CAAC,KAAW,EAAE,MAAM,GAAG,EAAE;;YAC9C,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,SAAS,EAAE,KAAK,CAAC,UAAU,CAAC,SAAS,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YAClF,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;YACvD,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QAC1C,CAAC;KAAA;IAED,oCAAoC;IACtB,aAAa,CAAC,KAAW,EAAE,MAAM,GAAG,EAAE;;YAChD,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;YAC/C,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC;YACvD,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,WAAW,EAAE,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;QACnF,CAAC;KAAA;;AAzdM,cAAK,GAAqC,EAAE,CAAC;AATxD,4BAmeC;AAED,kBAAe,QAAQ,CAAC;;;;;;;;;;;;;;;ACphBxB,wHAQ0B;AAS1B;IAYI,YAAY,QAAgB;QAN5B,aAAQ,GAAmC,EAAE,CAAC;QAC9C,cAAS,GAAc,EAAE,CAAC;QAMtB,IAAI,CAAC,EAAE,GAAG,IAAI,CAAC,QAAQ,GAAG,gCAAa,CAAC,QAAQ,CAAC,CAAC;QAClD,IAAI,CAAC,OAAO,GAAG,0BAAO,CAAC,QAAQ,CAAC,CAAC;QACjC,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;IACnB,CAAC;IAED;;;;;;OAMG;IACH,OAAO,CAAC,EAAU,EAAE,SAAkC,EAAE,EAAE,QAAQ,GAAG,EAAE;QAInE,IAAI,QAAQ,GAAG,4BAAS,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,OAAO,IAAI,GAAG;YAC/C,CAAC,CAAC,EAAE;YACJ,CAAC,CAAC,gCAAa,CAAC,IAAI,CAAC,OAAO,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC;QAC7C,IAAI,GAAG,GAAG,0BAAO,CAAC,QAAQ,CAAC,CAAC;QAE5B,IAAI,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE;YACxB,IAAI,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,EAChC,QAAQ,GAAG,EAAE,OAAO,EAAE,EAAE,EAAE,EAC1B,QAAQ,GAAG,CAAC,EAAU,EAAE,MAAM,GAAG,EAAE,EAAE,QAAQ,GAAG,EAAE,EAAE,EAAE;gBAClD,OAAO,OAAO,CAAC,OAAO,CAAC,EAAE,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;YACjD,CAAC,CAAC;YAEN,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,OAAO,CAAC;YAElC,IAAI,EAAE,GAAG,cAAc,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YAE7D,EAAE,CAAC,IAAI,CACH,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,GAAG,EACH,QAAQ,EACR,MAAM,EACN,yBAAM,EACN,GAAG,kCAAe,CAAC,MAAM,CAAC,CAC7B,CAAC;YAEF,OAAO,QAAQ,CAAC;SACnB;aAAM;YACH,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;SAC/D;IACL,CAAC;;AAnDM,YAAK,GAAmC,EAAE,CAAC;AAC3C,iBAAU,GAAsC,EAAE,CAAC;AAV9D,wBA6DC;AAED,MAAM,MAAM,GAAG,gEAAgE,CAAC;AAChF,MAAM,MAAM,GAAG,yDAAyD,CAAC;AACzE,MAAM,SAAS,GAAG,uCAAuC,CAAC;AAC1D,MAAM,QAAQ,GAAG,gCAAgC,CAAC;AAElD,mEAAmE;AACnE,0EAA0E;AAC1E,6EAA6E;AAC7E,8EAA8E;AAC9E,iBAAiB;AACjB,MAAM,YAAY,GAAG,wCAAqB,CAAC,IAAI,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;AAE1E,wBAAwB,QAAgB,EAAE,IAAY,EAAE,MAEvD;IACG,IAAI,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAE3C,IAAI;QACA,OAAO,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;KACnE;IAAC,OAAO,GAAG,EAAE;QACV,IAAI,GAAG,YAAY,WAAW,EAAE,EAAE,2BAA2B;YACzD,GAAG,CAAC,OAAO,GAAG,wBAAwB,CAAC;YAEvC,IAAI,MAAM,GAAG,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAEnC,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAC;YACvD,GAAG,CAAC,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAE9B,MAAM,GAAG,CAAC;SACb;aAAM;YACH,MAAM,YAAY,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;SACrC;KACJ;AACL,CAAC;AAED,kDAAkD;AAClD,qBAAqB,QAAgB;IACjC,IAAI,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;IACvC,OAAO,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;AACrC,CAAC;AAED,+DAA+D;AAC/D,2BAA2B,IAAY,EAAE,IAAY;IACjD,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAC1B,QAAQ,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,EACzC,QAAgB,EAAE,OAAyB,CAAC;IAEhD,IAAI,QAAQ,EAAE;QACV,IAAI,EAAE,GAAG,IAAI,MAAM,CAAC,SAAS,QAAQ,sBAAsB,CAAC,EACxD,QAAkB,EAAE,QAAgB,CAAC;QAEzC,KAAK,IAAI,CAAC,IAAI,OAAO,EAAE;YACnB,OAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YAE/B,IAAI,OAAO,EAAE;gBACT,QAAQ,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzC,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;gBAEtB,MAAM;aACT;SACJ;QAED,IAAI,QAAQ,IAAI,QAAQ,IAAI,QAAQ,CAAC,MAAM,EAAE;YACzC,QAAQ,CAAC,OAAO,EAAE,CAAC;YACnB,IAAI,EAAE,GAAG,IAAI,MAAM,CAAC,SAAS,QAAQ,sBAAsB,CAAC,CAAC;YAE7D,KAAK,IAAI,IAAI,IAAI,QAAQ,EAAE;gBACvB,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;gBAEzB,IAAI,OAAO;oBACP,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;aAChD;SACJ;aAAM;YACH,OAAO,EAAE,CAAC;SACb;KACJ;SAAM;QACH,uEAAuE;QACvE,mBAAmB;QACnB,QAAQ,GAAG,OAAO,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;QAC7B,OAAO,GAAG,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QAEhD,OAAO,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;KAC3D;AACL,CAAC;AAED;;;GAGG;AACH,sBAA6B,GAAU,EAAE,QAAgB;IACrD,IAAI,MAAM,GAAG,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,CAAC;IAE7C,KAAK,IAAI,CAAC,IAAI,MAAM,EAAE;QAClB,4DAA4D;QAC5D,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ;YAAE,SAAS;QAE/C,IAAI,OAAO,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QAEtC,IAAI,OAAO,EAAE;YACT,IAAI,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,EACrB,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAC5B,IAAI,GAAW,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAChC,MAAM,GAAW,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAClC,4DAA4D;YAC5D,+DAA+D;YAC/D,yDAAyD;YACzD,MAAM,GAAG;gBACL,QAAQ;gBACR,QAAQ;gBACR,IAAI,EAAE,IAAI,GAAG,YAAY,CAAC,IAAI;gBAC9B,MAAM;aACT;YACD,0CAA0C;YAC1C,GAAG,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,EAC9C,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC;YAEvC,6DAA6D;YAC7D,gCAAgC;YAChC,IAAI,MAAM,CAAC,IAAI,IAAI,CAAC;gBAChB,MAAM,CAAC,MAAM,GAAG,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC;YAEjD,0DAA0D;YAC1D,QAAQ,GAAG,iBAAiB,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;YAEhD,iEAAiE;YACjE,MAAM,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC;YAC5B,2CAA2C;YAC3C,MAAM,CAAC,MAAM,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC;YAExD,MAAM,CAAC,CAAC,CAAC,GAAG,UAAU,MAAM,CAAC,QAAQ,KAAK,MAAM,CAAC,QAAQ,EAAE;kBACrD,IAAI,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC;SAC7C;KACJ;IAED,8BAA8B;IAC9B,MAAM,CAAC,OAAO,EAAE,CAAC;IACjB,GAAG,CAAC,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAE9B,OAAO,GAAG,CAAC;AACf,CAAC;AAlDD,oCAkDC;;;;;;;;;;;;AC3ND,+B","file":"whatstpl.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"whatstpl\"] = factory();\n\telse\n\t\troot[\"whatstpl\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass UnclosedTagError extends SyntaxError {\n    constructor(message, filename, line, column) {\n        super(message);\n        this.filename = filename;\n        this.line = line;\n        this.column = column;\n    }\n}\nexports.UnclosedTagError = UnclosedTagError;\n//# sourceMappingURL=errors.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./errors\"));\n__export(require(\"./parser\"));\n__export(require(\"./utils\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_1 = require(\"./errors\");\nconst utils_1 = require(\"./utils\");\nconst AttrRe = /([0-9a-zA-Z:\\-]+)\\s*=\\s*|([0-9a-zA-Z:\\-]+)\\s*/;\nclass Parser {\n    constructor(filename = \"\") {\n        this.listeners = {};\n        this.outputTags = Parser.OutputTags;\n        this.blockTags = Parser.BlockTags;\n        if (filename)\n            this.filename = utils_1.getAbsPath(filename);\n        else\n            this.filename = \"undefined\";\n        this.renewRegExp();\n        this.on(\"block\", (node) => {\n            let attrs = node.attributes;\n            if (node.tag == \"block\") {\n                this.blockTags.push(attrs.name.value);\n                this.renewRegExp();\n            }\n            else if (node.tag == \"import\" && attrs.target && attrs.target.value) {\n                let tags = attrs.target.value.split(/,\\s*/);\n                for (let i in tags) {\n                    let pair = tags[i].split(/\\s+as\\s+/);\n                    tags[i] = pair[1] || pair[0];\n                }\n                this.blockTags = this.blockTags.concat(tags);\n                this.renewRegExp();\n            }\n        });\n    }\n    renewRegExp() {\n        let tagStr = this.blockTags.join(\"|\");\n        let pattern = \"<!--(.*?)-->|<!--(.*)|(\"\n            + this.outputTags.join(\"|\")\n            + \")\\{(.+?)\\}|<(\"\n            + tagStr\n            + \")[\\\\s|\\\\/|>]|<\\\\/(\"\n            + tagStr\n            + \")>\";\n        this.regexp = new RegExp(pattern);\n    }\n    on(event, listener) {\n        if (!this.listeners[event])\n            this.listeners[event] = [];\n        this.listeners[event].push(listener);\n    }\n    emit(event, ...args) {\n        if (!this.listeners[event] || !this.listeners[event].length)\n            return false;\n        for (let listener of this.listeners[event]) {\n            listener(...args);\n        }\n        return true;\n    }\n    parse(html) {\n        let root = {\n            tag: \"root\",\n            type: \"root\",\n            line: 1,\n            column: 1,\n            contents: [],\n            closed: false\n        };\n        this.html = html.trimRight().replace(/\\r\\n|\\r/g, \"\\n\");\n        this.parseHtml(this.html, 1, 1, root);\n        return root;\n    }\n    getLine(html, line) {\n        let lineStr, left;\n        while (true) {\n            let end = html.indexOf(\"\\n\");\n            lineStr = (end >= 0 ? html.substring(0, end) : html).trimRight();\n            left = end >= 0 ? html.substring(end + 1) : \"\";\n            if (lineStr || !left) {\n                break;\n            }\n            else {\n                line += 1;\n                html = left;\n            }\n        }\n        return { lineStr, left, line };\n    }\n    attachTextNode(lineStr, line, column, endIndex, nodes) {\n        let textNode = {\n            type: \"text\",\n            line,\n            column,\n            contents: endIndex ? lineStr.substring(0, endIndex) : lineStr + \"\\n\",\n            closed: true,\n        };\n        if (textNode.contents.trimLeft()) {\n            nodes.push(textNode);\n            this.emit(\"text\", textNode);\n        }\n    }\n    parseHtml(html, line, column = 1, parent) {\n        let LineInfo = this.getLine(html, line), lineStr = LineInfo.lineStr, matches = lineStr.match(this.regexp), nodes = parent.contents;\n        html = LineInfo.left;\n        line = LineInfo.line;\n        if (!matches) {\n            if (parent.tag == \"script\"\n                && parent.attributes.engine\n                && parent.attributes.engine.value == Parser.EngineName) {\n                let snippetNode = {\n                    type: \"snippet\",\n                    line,\n                    column,\n                    contents: lineStr + \"\\n\",\n                    closed: true,\n                };\n                nodes.push(snippetNode);\n                this.emit(\"snippet\", snippetNode);\n            }\n            else {\n                this.attachTextNode(lineStr, line, column, NaN, nodes);\n            }\n            line += 1;\n            column = 1;\n        }\n        else if (matches[1] && parent.tag != \"script\") {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n            let left = lineStr.substring(matches.index + matches[0].length), commentNode = {\n                type: \"comment\",\n                line,\n                column,\n                contents: matches[0],\n                closed: false\n            };\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n            if (left) {\n                html = left + \"\\n\" + html;\n                column += matches[0].length;\n            }\n            else {\n                commentNode.contents += \"\\n\";\n                line += 1;\n                column = 1;\n            }\n        }\n        else if (matches[2] && parent.tag != \"script\") {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n            let commentNode = {\n                type: \"comment\",\n                line,\n                column,\n                contents: lineStr.substring(matches.index),\n                closed: false\n            };\n            line += 1;\n            column = 1;\n            let res = this.parseComment(html, line, column, commentNode);\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        }\n        else if (matches[3] && matches[4]) {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n            column += 2;\n            let varNode = {\n                tag: matches[3],\n                type: \"var\",\n                line,\n                column,\n                contents: matches[4],\n                closed: true,\n            };\n            nodes.push(varNode);\n            this.emit(\"var\", varNode);\n            let endColumn = matches.index + matches[4].length + 3, left = lineStr.substring(endColumn);\n            if (left.trimRight()) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[4].length + 1;\n            }\n            else {\n                line += 1;\n                column = 1;\n            }\n        }\n        else if (matches[5] && parent.tag != \"script\") {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n            let endColumn = matches.index + matches[0].length, ending = lineStr[endColumn - 1], blockNode = {\n                tag: matches[5],\n                type: \"block\",\n                line,\n                column,\n                attributes: {},\n                contents: [],\n                closed: false,\n            };\n            if (ending == \"/\" || ending == \">\")\n                endColumn -= 1;\n            let left = lineStr.substring(endColumn);\n            if (!left && html) {\n                column = 1;\n                let LineInfo = this.getLine(html, line);\n                if (LineInfo.lineStr) {\n                    left = LineInfo.lineStr;\n                    html = LineInfo.left;\n                }\n            }\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[0].length;\n            }\n            else {\n                throw new errors_1.UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            }\n            let res = this.applyAttr(html, line, column, blockNode.attributes);\n            blockNode.closed = res.blockClosed;\n            if (res.left && !blockNode.closed) {\n                res = this.parseHtml(res.left, res.line, res.column, blockNode);\n            }\n            nodes.push(blockNode);\n            this.emit(\"block\", blockNode);\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        }\n        else if (matches[6] && matches[6] == parent.tag) {\n            if (matches.index && parent.tag != \"script\") {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n            }\n            parent.closed = true;\n            let endColumn = matches.index + matches[0].length, left = lineStr.substring(endColumn);\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += endColumn;\n            }\n            else {\n                line += 1;\n                column = 1;\n            }\n        }\n        else {\n            this.attachTextNode(lineStr, line, column, NaN, nodes);\n            line += 1;\n            column = 1;\n        }\n        if (html && !parent.closed) {\n            return this.parseHtml(html, line, column, parent);\n        }\n        else {\n            parent.closed = true;\n            return { line, column, left: html };\n        }\n    }\n    applyAttr(html, line, column, attrs) {\n        let LineInfo = this.getLine(html, line), lineStr = LineInfo.lineStr, matches = lineStr.match(AttrRe);\n        line = LineInfo.line;\n        html = LineInfo.left;\n        if (!matches) {\n            let i = lineStr.indexOf(\">\");\n            if (i === -1) {\n                throw new errors_1.UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            }\n            else {\n                column += i + 1;\n                let left = lineStr.substring(i + 1);\n                if (left) {\n                    html = left + \"\\n\" + html;\n                }\n                else {\n                    line += 1;\n                    column = 1;\n                }\n            }\n            return {\n                line,\n                column,\n                left: html,\n                blockClosed: lineStr[i - 1] == \"/\"\n            };\n        }\n        let name;\n        let value;\n        let noQuote = true;\n        let ending;\n        let blockClosed;\n        let left;\n        if (matches[1]) {\n            let pos = matches.index + matches[0].length, quote = lineStr[pos], end;\n            noQuote = quote != \"'\" && quote != '\"';\n            if (!noQuote)\n                pos += 1;\n            if (!noQuote) {\n                end = lineStr.indexOf(quote, pos);\n            }\n            else {\n                end = lineStr.indexOf(\"/\", pos);\n                if (end === -1)\n                    end = lineStr.indexOf(\">\", pos);\n            }\n            name = matches[1],\n                value = end === -1 ? \"\" : lineStr.substring(pos, end);\n            left = lineStr.substring(end + 1);\n            column += pos;\n        }\n        else if (matches[2]) {\n            name = value = matches[2].trim();\n            left = lineStr.substring(matches.index + matches[0].length);\n            column += matches.index;\n        }\n        ending = left ? left.trimLeft()[0] : \"\";\n        blockClosed = ending == \"/\";\n        attrs[name] = { name, value, line, column };\n        if (ending == \"/\")\n            left = left.substring(2);\n        else if (ending == \">\")\n            left = left.substring(1);\n        if (left) {\n            html = left + \"\\n\" + html;\n            column += (matches[1] ? value.length : matches[0].length)\n                + (noQuote ? 0 : 1);\n        }\n        else {\n            line += 1;\n            column = 1;\n        }\n        if (!ending || (ending != \">\" && ending != \"/\")) {\n            return this.applyAttr(html, line, column, attrs);\n        }\n        else {\n            let i;\n            if (ending == \">\")\n                i = left.indexOf(\">\") + 1;\n            else if (ending == \"/\")\n                i = left.indexOf(\"/>\") + 2;\n            column += i;\n            return { line, column, left: html, blockClosed };\n        }\n    }\n    parseComment(html, line, column, commentNode) {\n        let LineInfo = this.getLine(html, line), lineStr = LineInfo.lineStr, matches = lineStr && lineStr.match(/-->/);\n        line = LineInfo.line;\n        html = LineInfo.left;\n        if (lineStr)\n            commentNode.contents += \"\\n\";\n        if (!matches) {\n            commentNode.contents += lineStr;\n            line += 1;\n            column = 1;\n            if (html) {\n                return this.parseComment(html, line, column, commentNode);\n            }\n            else {\n                return { line, column, left: html };\n            }\n        }\n        else {\n            if (matches.index) {\n                commentNode.contents += lineStr.substring(0, matches.index);\n            }\n            commentNode.contents += matches[0];\n            commentNode.closed = true;\n            column += matches.index + 3;\n            let left = lineStr.substring(column);\n            if (left) {\n                html = left + \"\\n\" + html;\n            }\n            else {\n                line += 1;\n                column = 1;\n            }\n        }\n        return { line, column, left: html };\n    }\n}\nParser.EngineName = \"whatstpl\";\nParser.BlockTags = [\n    \"layout\",\n    \"import\",\n    \"export\",\n    \"block\",\n    \"if\",\n    \"else-if\",\n    \"else\",\n    \"switch\",\n    \"case\",\n    \"default\",\n    \"for\",\n    \"while\",\n    \"do\",\n    \"continue\",\n    \"break\",\n    \"script\",\n];\nParser.OutputTags = [\n    \"!\",\n    \"@\",\n    \"#\",\n];\nexports.Parser = Parser;\n//# sourceMappingURL=parser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IsBrowser = typeof window == \"object\"\n    && typeof XMLHttpRequest == \"function\";\nexports.Separator = exports.IsBrowser ? \"/\" :\n    (process.platform == \"win32\" ? \"\\\\\" : \"/\");\nfunction escape(html) {\n    return String(html).replace(/<\\/?[^>]*>/g, \"\");\n}\nexports.escape = escape;\nfunction dirname(path) {\n    if (path == \"/\")\n        return path;\n    let i = path.replace(/\\\\/g, \"/\").lastIndexOf(\"/\");\n    if (i < 0 || path == \"/\")\n        return \".\";\n    else if (i == path.length - 1)\n        return dirname(path.substring(0, i));\n    else\n        return path.substring(0, i).replace(/\\/|\\\\/g, exports.Separator);\n}\nexports.dirname = dirname;\nfunction basename(filename, extname = \"\") {\n    let dir = dirname(filename), basename = (dir == \"./\" && filename.match(/^\\.[\\/\\\\]/) == null)\n        ? filename : filename.substring(dir.length + 1);\n    if (extname) {\n        let i = basename.lastIndexOf(extname);\n        basename = i >= 0 ? basename.substring(0, i) : basename;\n    }\n    return basename;\n}\nexports.basename = basename;\nfunction extname(filename) {\n    let baseName = basename(filename), i = baseName.lastIndexOf(\".\");\n    return i >= 0 ? baseName.substring(i) : \"\";\n}\nexports.extname = extname;\nfunction normalizePath(path) {\n    let parts = path.split(/\\/|\\\\/);\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i] == \"..\") {\n            parts.splice(i - 1, 2);\n            i -= 2;\n        }\n        else if (parts[i] == \".\") {\n            parts.splice(i, 1);\n            i -= 1;\n        }\n    }\n    return parts.join(exports.Separator);\n}\nexports.normalizePath = normalizePath;\nfunction getCwd() {\n    if (exports.IsBrowser) {\n        return location.protocol + \"//\" + location.host\n            + dirname(location.pathname);\n    }\n    else {\n        return process.cwd();\n    }\n}\nexports.getCwd = getCwd;\nfunction isAbsPath(path) {\n    return path[0] == \"/\" || path.match(/^[a-zA-Z0-9]+:[\\/\\\\]/) != null;\n}\nexports.isAbsPath = isAbsPath;\nfunction getAbsPath(filename) {\n    if (!isAbsPath(filename)) {\n        let dir = getCwd(), noSep = dir[dir.length - 1] == \"/\";\n        filename = dir + (noSep ? \"\" : exports.Separator) + filename;\n    }\n    return normalizePath(filename);\n}\nexports.getAbsPath = getAbsPath;\nfunction getObjectValues(obj) {\n    let res = [];\n    for (let prop in obj) {\n        if (obj.hasOwnProperty(prop))\n            res.push(obj[prop]);\n    }\n    return res;\n}\nexports.getObjectValues = getObjectValues;\nfunction getFunctionBodyOffset(fn) {\n    let fnStr = fn.toString(), i = fnStr.indexOf(\"{\") + 1, defArr = fnStr.slice(0, i).split(\"\\n\"), inNewLine = fnStr[i] == \"\\n\", column = inNewLine ? 0 : defArr[defArr.length - 1].indexOf(\"{\") + 2, line = inNewLine ? defArr.length : defArr.length - 1;\n    return { line, column };\n}\nexports.getFunctionBodyOffset = getFunctionBodyOffset;\n//# sourceMappingURL=utils.js.map","import {\n    Node,\n    Parser,\n    escape,\n    isAbsPath,\n    extname,\n    dirname,\n    normalizePath,\n    getAbsPath,\n    getCwd,\n    Separator,\n    IsBrowser\n} from \"whatstpl-toolkit\";\nimport { Module, replaceError } from \"./module\";\n\nvar fs: {\n    readFile(filename: string, encoding: string, cb: (err: Error, data: string) => void);\n} = null;\n\nif (!IsBrowser) {\n    fs = require(\"fs\");\n}\n\nexport type Variables = { [name: string]: any };\nexport type Renderer = (locals?: Variables) => string;\n\nexport interface CompileOption {\n    /** For fs.readFile() to decode the file contents. */\n    encoding?: string;\n    /** Whether the compiled function should be cached in memory. */\n    cache?: boolean;\n    /** Whether or not to remove the comments when ernder HTML. */\n    removeComments?: boolean;\n    /**\n     * Used when the program is run in a browser and load remote template via \n     * Ajax.\n     */\n    timeout?: number;\n}\n\nexport const CompileOption: CompileOption = {\n    encoding: \"utf8\",\n    cache: false,\n    removeComments: false,\n    timeout: 5000\n}\n\nexport class Template {\n    filename: string;\n    options: CompileOption;\n    module: Module;\n\n    private currentLine: number = 0;\n    private importedModuleCount: number = 0;\n    private layouts: Array<{ filename: string, node: Node }> = [];\n\n    static cache: { [filename: string]: Renderer } = {};\n\n    constructor(filename?: string, encoding?: string);\n    constructor(filename?: string, options?: CompileOption);\n    constructor(filename = \"\", options: any = \"utf8\") {\n        if (filename)\n            this.filename = getAbsPath(filename);\n        else\n            this.filename = \"undefined\";\n\n        if (typeof options == \"string\")\n            options = { encoding: options };\n\n        this.options = Object.assign({}, CompileOption, options);\n    }\n\n    /** Renders the given template contents. */\n    async render(tpl: string, locals: Variables = {}): Promise<string> {\n        let render = await this.compile(tpl);\n        return render(locals);\n    }\n\n    /** Renders the given file. */\n    static async renderFile(filename?: string, locals?: Variables, encoding?: string): Promise<string>;\n    static async renderFile(filename?: string, locals?: Variables, options?: CompileOption): Promise<string>;\n    static async renderFile(filename: string, locals: Variables = null, options = null): Promise<string> {\n        let render = await this.compileFile(filename, options);\n        return render(locals || {});\n    }\n\n    /** Compiles the given template contents. */\n    async compile(tpl: string): Promise<Renderer> {\n        // If the function is already cached, retrieve it instead.\n        if (this.options.cache && Template.cache[this.filename]) {\n            return Template.cache[this.filename];\n        }\n\n        let parser = new Parser(this.filename),\n            node: Node = parser.parse(tpl),\n            _module: Module = await this.createModule(node);\n\n        // Wrap the function in a render function, so when it is  called, the \n        // program can catch and re-throw any errors, and only  return the \n        // `default` property (HTML) from the module.\n        let render: Renderer = (locals = {}) => {\n            try {\n                return _module.require(this.filename, locals).default;\n            } catch (err) { // replace and re-throw the error.\n                throw replaceError(err, this.filename);\n            }\n        };\n\n        if (this.options.cache)\n            Template.cache[this.filename] = render;\n\n        return render;\n    }\n\n    /** Compiles the given file. */\n    static async compileFile(filename: string, encoding?: string): Promise<Renderer>;\n    static async compileFile(filename: string, options?: CompileOption): Promise<Renderer>;\n    static async compileFile(filename: string, options: any = null): Promise<Renderer> {\n        filename = getAbsPath(filename);\n\n        // If the function is already cached, retrieve it instead.\n        if (options && options.cache && Template.cache[filename]) {\n            return Template.cache[filename];\n        }\n\n        let tpl: Template = new this(filename, options),\n            html = await tpl.loadTemplate();\n\n        return tpl.compile(html);\n    }\n\n    /** Loads the template contents from the file. */\n    protected loadTemplate(): Promise<string> {\n        if (!IsBrowser) {\n            return new Promise((resolve, reject) => {\n                fs.readFile(this.filename, this.options.encoding, (err, data) => {\n                    err ? reject(err) : resolve(data);\n                });\n            });\n        } else {\n            return new Promise((resolve, reject) => {\n                let xhr = new XMLHttpRequest();\n                xhr.timeout = this.options.timeout;\n                xhr.open(\"GET\", this.filename, true);\n                xhr.onload = () => {\n                    resolve(xhr.responseText);\n                };\n                xhr.onabort = xhr.onerror = xhr.ontimeout = () => {\n                    reject(new Error(\"failed to load remote module.\"));\n                };\n                xhr.send();\n            });\n        }\n    }\n\n    /** Gets the absolute path of the filename, if it is relative.  */\n    protected getAbsPath(filename: string): string {\n        if (!isAbsPath(filename)) {\n            let dir = this.filename && this.filename != \"undefined\"\n                ? dirname(this.filename)\n                : getCwd();\n\n            filename = normalizePath(dir + Separator + filename);\n        }\n\n        // If the extension name is omitted, use the one of the parent file.\n        if (!extname(filename)) {\n            filename += extname(this.filename);\n        }\n\n        return filename;\n    }\n\n    /** Adds a line of source map to the internal `sourceMap` property.  */\n    private addSourceMap(column: number, node: Node) {\n        this.currentLine += 1;\n        this.module.sourceMap[this.currentLine] = { column, node };\n    }\n\n    /** Pushes a line of code to the internal `code` object. */\n    protected pushCode(before: string, contents: string, after: string, node: Node, lineEnding = true) {\n        this.module.code += before + contents + after + (lineEnding ? \"\\n\" : \"\");\n        // `length` of a string starts from 0, but column number starts from 1,\n        // so here it should add 1. \n        this.addSourceMap(before.length + 1, node);\n    }\n\n    /** Imports a module from the given file. */\n    protected async importModule(parent: Module = null): Promise<Module> {\n        if (this.options.cache && Module.cache[this.filename]) {\n            return Module.cache[this.filename];\n        }\n\n        let tpl = await this.loadTemplate(),\n            parser = new Parser(this.filename),\n            node = parser.parse(tpl);\n\n        return this.createModule(node, parent);\n    }\n\n    /** Creates a new module according to the given filename and node tree. */\n    private async createModule(node: Node, parent: Module = null): Promise<Module> {\n        let _module = new Module(this.filename);\n\n        this.module = _module;\n\n        await this.attachBlockContents(node);\n\n        // If there is any layouts, push then to the very bottom of the \n        // compiled code, and in the layout module, use variable `__contents` \n        // to  attach the inner contents.\n        if (this.layouts.length) {\n            for (let { filename, node } of this.layouts) {\n                this.importedModuleCount += 1;\n\n                let moduleId = \"__module_\" + this.importedModuleCount;\n                filename = filename.replace(/\\\\/g, \"\\\\\\\\\");\n\n                // When dealing with layout, only import the `default` property,\n                // and reassign the `default` in the current module.\n                this.pushCode(\n                    `const ${moduleId} = `,\n                    `require('${filename}', __locals, this.default)`,\n                    \";\",\n                    node\n                );\n                this.pushCode(\"this.default = \", `${moduleId}.default`, \";\", node);\n            }\n        }\n\n        _module.parent = parent;\n        Module.cache[this.filename] = _module; // cache the module.\n        Module.sourceMaps[this.filename] = _module.sourceMap; // cache the source map.\n\n        return _module;\n    }\n\n    /** Attaches block contents to the internal `code` object. */\n    private async attachBlockContents(parent: Node, indent = \"\") {\n        let cutSpace = NaN;\n\n        for (let node of <Node[]>parent.contents) {\n            if (node.type == \"text\"\n                || (node.type == \"comment\" && !this.options.removeComments)) {\n                let contents = (<string>node.contents).replace(/\\n/g, \"\\\\n\")\n                    .replace(/'/g, \"\\\\'\");\n\n                this.pushCode(\n                    indent + \"this.default += '\",\n                    contents,\n                    \"';\",\n                    node\n                );\n            } else if (node.type == \"var\") {\n                if (node.tag == \"!\") { // !{statement}\n                    this.pushCode(indent, <string>node.contents, \";\", node);\n                } else if (node.tag == \"@\") { // @{statement}\n                    this.pushCode(\n                        indent + \"this.default += \",\n                        <string>node.contents,\n                        \";\",\n                        node\n                    );\n                } else { // #{statement}\n                    this.pushCode(\n                        indent + \"this.default += __escape(\",\n                        <string>node.contents,\n                        \");\",\n                        node\n                    );\n                }\n            } else if (node.type == \"snippet\") { // <script engine=\"whatstpl\"></script>\n                // if (isNaN(cutSpace)) {\n                //     let match = (<string>node.contents).match(/\\S/);\n\n                //     if (match)\n                //         cutSpace = match.index;\n                // }\n\n                let contents: string = cutSpace\n                    ? (<string>node.contents).substring(cutSpace)\n                    : <string>node.contents;\n\n                this.pushCode(indent.substring(4), contents, \"\", node, false);\n            } else if (node.type == \"block\") {\n                if (node.tag == \"import\") { // <import/>\n                    await this.attachImport(node, indent);\n                } else if (node.tag == \"export\") { // <export/>\n                    await this.attachExport(node, indent);\n                } else if (node.tag == \"block\") { // <block></block>\n                    await this.attackBlock(node, indent);\n                } else if (node.tag == \"if\") { // <if></if>\n                    await this.attachIf(node, indent);\n                } else if (node.tag == \"else-if\") { // <else-if></else-if>\n                    await this.attachElseIf(node, indent.substring(4));\n                } else if (node.tag == \"else\") { // <else></else>\n                    await this.attachElse(node, indent.substring(4));\n                } else if (node.tag == \"switch\") { // <switch></switch>\n                    await this.attachSwitch(node, indent);\n                } else if (node.tag == \"case\") { // <case></case>\n                    await this.attachCase(node, indent);\n                } else if (node.tag == \"default\") { // <default></default>\n                    await this.attachDefault(node, indent);\n                } else if (node.tag == \"for\") { // <for></for>\n                    await this.attachFor(node, indent);\n                } else if (node.tag == \"while\") { // <while></while>\n                    await this.attachWhile(node, indent);\n                } else if (node.tag == \"do\") { // <do></do>\n                    await this.attachDoWhile(node, indent);\n                } else if (node.tag == \"continue\" || node.tag == \"break\") {\n                    // <continue/> and <break/>\n                    this.pushCode(indent, node.tag, \";\", node);\n                } else if (node.tag == \"layout\") { // <layout></layout>\n                    await this.attachLayout(node, indent);\n                } else if (node.tag == \"script\") { // <script></script>\n                    let attrs = node.attributes;\n                    let shouldCompile = !attrs.engine\n                        || attrs.engine.value != Parser.EngineName;\n\n                    if (shouldCompile) { // JavaScript of the HTML.\n                        let contents = \"<script\";\n\n                        // attach attributes.\n                        for (let name in attrs) {\n                            contents += ` ${name}=\"${attrs[name].value}\"`;\n                        }\n\n                        contents += \">\\\\n\";\n                        this.pushCode(\n                            indent + \"this.default += '\",\n                            contents,\n                            \"';\",\n                            node\n                        );\n                    }\n\n                    // Attaches the contents in the <script> element.\n                    await this.attachBlockContents(node, indent + \"    \");\n\n                    if (shouldCompile) {\n                        this.pushCode(\n                            indent + \"this.default += '\",\n                            \"</script>\\\\n\",\n                            \"';\",\n                            node\n                        );\n                    }\n                } else { // user-defined block tags.\n                    let name = node.tag.replace(/-/g, \"_\"),\n                        attrs = node.attributes;\n\n                    if (attrs.await && attrs.await.value != \"false\")\n                        name = \"await \" + name;\n\n                    let contents = \"call(this\";\n\n                    // User-defined block tags are treated as function, when \n                    // called, the attribute `data` will be used as arguments\n                    // and passed to the function.\n                    if (attrs.data && attrs.data.value)\n                        contents += \", \" + attrs.data.value;\n\n                    contents += \")\";\n\n                    this.pushCode(indent + name + \".\", contents, \";\", node);\n                }\n            }\n        }\n    }\n\n    /** <layout file=\"<filename>\"/> */\n    private async attachLayout(node: Node, indent = \"\") {\n        let filename = this.getAbsPath(node.attributes.file.value),\n            tpl: Template = new (<any>this.constructor)(filename, this.options);\n\n        await tpl.importModule(this.module);\n\n        // The layouts are not attached immediately, they will be stored in \n        // an array, when the current module is compiled, layouts will be \n        // added to the very end of the compiled code.\n        this.layouts.push({ filename, node });\n    }\n\n    /** <import[ target=\"<block-name>\"] file|from=\"<filename>\"/> */\n    private async attachImport(node: Node, indent = \"\") {\n        let attrs = node.attributes,\n            filename = this.getAbsPath(attrs.from ? attrs.from.value : attrs.file.value),\n            tpl: Template = new (<any>this.constructor)(filename, this.options);\n\n        await tpl.importModule(this.module);\n\n        this.importedModuleCount += 1;\n\n        let moduleId = \"__module_\" + this.importedModuleCount;\n        filename = filename.replace(/\\\\/g, \"\\\\\\\\\");\n        this.pushCode(\n            `${indent}const ${moduleId} = `,\n            `require('${filename}', __locals)`,\n            \";\",\n            node\n        );\n\n        // The 'target' attribute in a <import/> elements sets which names \n        // should be imported.\n        if (attrs.target && attrs.target.value) {\n            let tags = attrs.target.value.replace(/-/g, \"_\").split(/\\s*,\\s*/);\n\n            for (let tag of tags) {\n                // parse as syntax.\n                let pair = tag.split(/\\s*as\\s*/),\n                    oldName = pair[0],\n                    newName = pair[1] || oldName;\n\n                this.pushCode(\n                    indent,\n                    `const ${newName} = ${moduleId}.${oldName}`,\n                    \";\",\n                    node\n                );\n            }\n        } else { // If no 'target', then import the `default` property.\n            this.pushCode(indent, `this.default += ${moduleId}.default`, \";\", node);\n        }\n    }\n\n    /** <export target=\"<block-names>\"/> */\n    private async attachExport(node: Node, indent = \"\") {\n        // The 'target' attribute in a <export/> elements sets which names \n        // should be exported and can be imported by other modules.\n        if (node.attributes.target && node.attributes.target.value) {\n            let tags = node.attributes.target.value.split(/,\\s*/);\n\n            for (let i in tags) {\n                // parse `as` syntax\n                let pair = tags[i].split(/\\s+as\\s+/),\n                    oldName = pair[0].replace(/-/g, \"_\"),\n                    newName = pair[1] ? pair[1].replace(/-/g, \"_\") : oldName;\n\n                this.pushCode(indent, `this.${newName} = ${oldName}`, \";\", node);\n            }\n        }\n    }\n\n    /** <block name=\"<name>\"[ export][ async][ params=\"<params>\"]></block> */\n    private async attackBlock(block: Node, indent = \"\") {\n        let attrs = block.attributes,\n            name = attrs.name.value.replace(/-/g, \"_\"),\n            contents = `function ${name}(`;\n\n        // 'async' attribute means the function is an async function.\n        if (attrs.async && attrs.async.value != \"false\")\n            contents = `async ` + contents;\n\n        // 'params' attribute sets function parameters.\n        if (attrs.params && attrs.params.value)\n            contents += attrs.params.value;\n\n        contents += \")\";\n\n        this.pushCode(indent, contents, \" {\", block);\n\n        await this.attachBlockContents(block, indent + \"    \");\n\n        this.pushCode(indent, \"\", \"}\", block);\n\n        // The block can be exported by setting an 'export' attribute.\n        if (attrs.export && attrs.export.value != \"false\")\n            this.pushCode(indent, `this.${name} = ${name}`, \";\", block);\n    }\n\n    /** <if condition=\"<condition>\"></if> */\n    private async attachIf(block: Node, indent = \"\") {\n        this.pushCode(indent + \"if (\", block.attributes.condition.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <else-if condition=\"<condition>\"></else-if> */\n    private async attachElseIf(block: Node, indent = \"\") {\n        this.pushCode(indent + \"} else if (\", block.attributes.condition.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n    }\n\n    /** <else></else> */\n    private async attachElse(block: Node, indent = \"\") {\n        this.pushCode(indent + \"} else {\", \"\", \"\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n    }\n\n    /** <switch target=\"<target>\"></switch> */\n    private async attachSwitch(block: Node, indent = \"\") {\n        this.pushCode(indent + \"switch (\", block.attributes.target.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <case data=\"<data>\"></case> */\n    private async attachCase(block: Node, indent = \"\") {\n        this.pushCode(indent + \"case \", block.attributes.data.value, \":\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent + \"    \", \"break\", \";\", block);\n    }\n\n    /** <default></default> */\n    private async attachDefault(block: Node, indent = \"\") {\n        this.pushCode(indent + \"default\", \"\", \":\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent + \"    \", \"break\", \";\", block);\n    }\n\n    /** <for statement=\"<statement>\"></for> */\n    private async attachFor(block: Node, indent = \"\") {\n        this.pushCode(indent + \"for (\", block.attributes.statement.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <while condition=\"<condition>\"></while> */\n    private async attachWhile(block: Node, indent = \"\") {\n        this.pushCode(indent + \"while (\", block.attributes.condition.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <do while=\"<condition>\"></do> */\n    private async attachDoWhile(block: Node, indent = \"\") {\n        this.pushCode(indent + \"do \", \"\", \" {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent + \"} while (\", block.attributes.while.value, \");\", block);\n    }\n}\n\nexport default Template;","import {\n    normalizePath,\n    dirname,\n    isAbsPath,\n    escape,\n    getObjectValues,\n    getFunctionBodyOffset,\n    Node\n} from \"whatstpl-toolkit\";\n\nexport interface SourceMap {\n    [line: string]: {\n        column: number;\n        node: Node;\n    }\n}\n\nexport class Module {\n    id: string;\n    filename: string;\n    dirname: string;\n    code: string;\n    parent: Module;\n    children: { [filename: string]: Module } = {};\n    sourceMap: SourceMap = {};\n\n    static cache: { [filename: string]: Module } = {};\n    static sourceMaps: { [filename: string]: SourceMap } = {};\n\n    constructor(filename: string) {\n        this.id = this.filename = normalizePath(filename);\n        this.dirname = dirname(filename);\n        this.code = \"\";\n    }\n\n    /**\n     * \n     * @param id Module id, usually it's the module filename.\n     * @param locals Local variables passed to the module.\n     * @param contents Layout contents, used when the current module is a \n     *  layout module.\n     */\n    require(id: string, locals: { [name: string]: any } = {}, contents = \"\"): {\n        [name: string]: any;\n        default?: string;\n    } {\n        let filename = isAbsPath(id) || this.dirname == \".\"\n            ? id\n            : normalizePath(this.dirname + \"/\" + id);\n        let dir = dirname(filename);\n\n        if (Module.cache[filename]) {\n            let _module = Module.cache[filename],\n                _exports = { default: \"\" },\n                _require = (id: string, locals = {}, contents = \"\") => {\n                    return _module.require(id, locals, contents);\n                };\n\n            this.children[filename] = _module;\n\n            let fn = createFunction(this.filename, _module.code, locals);\n\n            fn.call(\n                _exports,\n                _require,\n                filename,\n                dir,\n                contents,\n                locals,\n                escape,\n                ...getObjectValues(locals)\n            );\n\n            return _exports;\n        } else {\n            throw new Error(\"the request module hasn't been imported!\");\n        }\n    }\n}\n\nconst Params = \"require, __filename, __dirname, __contents, __locals, __escape\";\nconst EvalRE = /at ([a-zA-Z0-9_\\.]+) \\(eval at.+<anonymous>:(\\d+:\\d+)\\)/;\nconst RequireRE = /const __module_\\d+ = require\\('(.+?)'/;\nconst FnCallRE = /([a-zA-Z0-9_]+).call\\(this.*\\)/;\n\n// The `new Function()` will generate a function which it's string \n// representation is different in different JavaScript engines, so here I \n// calculate out the function body offset from a test function, so that when \n// replacing the error, the program can calculate the accurate position of the\n// function body.\nconst FnBodyOffset = getFunctionBodyOffset(new Function(\"a, b\", \"a + b\"));\n\nfunction createFunction(filename: string, code: string, locals: {\n    [prop: string]: any\n}) {\n    let props = Object.keys(locals).join(\", \");\n\n    try {\n        return new Function(Params + (props ? \", \" + props : \"\"), code);\n    } catch (err) {\n        if (err instanceof SyntaxError) { // replace the error stack.\n            err.message = \"Unexpected token found\";\n            \n            let stacks = err.stack.split(\"\\n\");\n\n            stacks[1] = stacks[1].replace(\"<anonymous>\", filename);\n            err.stack = stacks.join(\"\\n\");\n            \n            throw err;\n        } else {\n            throw replaceError(err, filename);\n        }\n    }\n}\n\n/** Gets the function name from a line of code. */\nfunction getFuncName(lineCode: string): string {\n    let matches = lineCode.match(FnCallRE);\n    return matches ? matches[1] : \"\";\n}\n\n/** Gets the imported filename from a `require()` statement. */\nfunction getImportFilename(code: string, line: number): string {\n    let codeArr = code.split(\"\\n\"),\n        funcName = getFuncName(codeArr[line - 1]),\n        lineCode: string, matches: RegExpMatchArray;\n\n    if (funcName) {\n        let re = new RegExp(`const ${funcName} = (__module_\\\\d+)\\.`),\n            _codeArr: string[], moduleId: string;\n\n        for (let i in codeArr) {\n            matches = codeArr[i].match(re);\n\n            if (matches) {\n                _codeArr = codeArr.slice(0, parseInt(i));\n                moduleId = matches[1];\n\n                break;\n            }\n        }\n\n        if (moduleId && _codeArr && _codeArr.length) {\n            _codeArr.reverse();\n            let re = new RegExp(`const ${moduleId} = require\\\\('(.+?)'`);\n\n            for (let code of _codeArr) {\n                matches = code.match(re);\n\n                if (matches)\n                    return matches[1].replace(/\\\\\\\\/g, \"\\\\\");\n            }\n        } else {\n            return \"\";\n        }\n    } else {\n        // line number starts from 1, while array index starts from 0, so here \n        // must decrease 1.\n        lineCode = codeArr[line - 1];\n        matches = lineCode && lineCode.match(RequireRE);\n\n        return matches ? matches[1].replace(/\\\\\\\\/g, \"\\\\\") : \"\";\n    }\n}\n\n/**\n * Replaces error stack according to the source map.\n * @param filename The main module filename.\n */\nexport function replaceError(err: Error, filename: string): Error {\n    let stacks = err.stack.split(\"\\n\").reverse();\n\n    for (let i in stacks) {\n        // first line the the stack or failed to parse the filename.\n        if (stacks[i][0] != \" \" || !filename) continue;\n\n        let matches = stacks[i].match(EvalRE);\n\n        if (matches) {\n            let funcName = matches[1],\n                pair = matches[2].split(\":\"),\n                line: number = parseInt(pair[0]),\n                column: number = parseInt(pair[1]),\n                // The running code will be wrapped in a function which the \n                // definition takes at least one line, so here the line number \n                // should decrease according to the function body offset.\n                source = {\n                    funcName,\n                    filename,\n                    line: line - FnBodyOffset.line,\n                    column\n                },\n                /** The source map of one line of code. */\n                map = Module.sourceMaps[filename][source.line],\n                code = Module.cache[filename].code;\n\n            // If the source line is 1 (the first line), then the column \n            // should be calculated as well.\n            if (source.line == 1)\n                source.column = column - FnBodyOffset.column;\n\n            // recalculate the filename, move to the next import file.\n            filename = getImportFilename(code, source.line);\n\n            // Replace the line number to the line number in the source file.\n            source.line = map.node.line;\n            // Calculate and replace the column number.\n            source.column = (column - map.column) + map.node.column;\n\n            stacks[i] = `    at ${source.funcName} (${source.filename}`\n                + `:${source.line}:${source.column})`;\n        }\n    }\n\n    // Regenerate the error stack.\n    stacks.reverse();\n    err.stack = stacks.join(\"\\n\");\n\n    return err;\n}","module.exports = require(\"fs\");"],"sourceRoot":""}