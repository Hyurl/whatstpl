{"version":3,"sources":["webpack://whatstpl/webpack/universalModuleDefinition","webpack://whatstpl/webpack/bootstrap","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/util.js","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/errors.js","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/index.js","webpack://whatstpl/external \"fs\"","webpack://whatstpl/./src/module.ts","webpack://whatstpl/./node_modules/object-assign/index.js","webpack://whatstpl/./node_modules/whatstpl-toolkit/dist/parser.js","webpack://whatstpl/./src/index.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","w","s","dirname","path","replace","lastIndexOf","length","substring","Separator","basename","filename","extname","dir","match","normalizePath","parts","split","splice","join","getCwd","IsBrowser","location","protocol","host","pathname","process","cwd","isAbsPath","test","window","XMLHttpRequest","platform","escape","html","String","baseName","getAbsPath","getObjectValues","obj","res","prop","push","getFunctionBodyOffset","fn","fnStr","toString","indexOf","defArr","slice","inNewLine","column","line","extendStatics","__extends","setPrototypeOf","__proto__","Array","b","__","constructor","create","UnclosedTagError","_super","message","_this","SyntaxError","__export","require","whatstpl_toolkit_1","Module","children","sourceMap","id","code","locals","contents","cache","_module_1","_exports","default","props","keys","Function","Params","err","stacks","stack","replaceError","createFunction","apply","concat","Error","sourceMaps","EvalRE","RequireRE","FnCallRE","FnBodyOffset","getImportFilename","lineCode","matches","codeArr","funcName","getFuncName","re","RegExp","_codeArr","parseInt","reverse","re_1","_i","_codeArr_1","pair","source","map","node","getOwnPropertySymbols","propIsEnumerable","propertyIsEnumerable","assign","test1","getOwnPropertyNames","test2","fromCharCode","test3","forEach","letter","shouldUseNative","target","from","symbols","to","val","undefined","TypeError","toObject","arguments","key","errors_1","util_1","AttrRe","Parser","listeners","outputTags","OutputTags","blockTags","BlockTags","renewRegExp","on","attrs","attributes","tag","tags","tagStr","pattern","regexp","event","listener","emit","args","_a","_b","parse","type","closed","trimRight","parseHtml","getLine","lineStr","left","end","attachTextNode","endIndex","nodes","keepPureSpaces","textNode","trimLeft","parent","LineInfo","index","commentNode","parseComment","varNode","endColumn","ending","tagClosed","blockNode","LineInfo_1","applyAttr","blockClosed","NaN","engine","EngineName","snippetNode","leading","left_1","quoted","pos","quote","trim","module_1","fs","CompileOption","encoding","removeComments","timeout","withCredentials","headers","Template","options","currentLine","importedModuleCount","layouts","render","tpl","compile","sent","renderFile","compileFile","parser","createModule","_module","loadTemplate","register","Promise","resolve","reject","xhr","open","name_1","isArray","setRequestHeader","onload","responseText","onabort","onerror","ontimeout","send","readFile","data","addSourceMap","pushCode","before","after","lineEnding","importModule","attachBlockContents","_c","node_1","indent","cutSpace","attachImport","attachExport","attackBlock","attachIf","attachElseIf","attachElse","attachSwitch","attachCase","attachDefault","attachFor","attachWhile","attachDoWhile","attachLayout","shouldCompile","name_2","name_3","await","file","tags_1","oldName","newName","block","async","params","export","condition","statement","while"],"mappings":"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","file":"whatstpl.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"whatstpl\"] = factory();\n\telse\n\t\troot[\"whatstpl\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IsBrowser = typeof window == \"object\"\n    && typeof XMLHttpRequest == \"function\";\nexports.Separator = exports.IsBrowser ? \"/\" :\n    (process.platform == \"win32\" ? \"\\\\\" : \"/\");\nfunction escape(html) {\n    return String(html).replace(/<\\/?[^>]*>/g, \"\");\n}\nexports.escape = escape;\nfunction dirname(path) {\n    if (path == \"/\")\n        return path;\n    var i = path.replace(/\\\\/g, \"/\").lastIndexOf(\"/\");\n    if (i < 0 || path == \"/\")\n        return \".\";\n    else if (i == path.length - 1)\n        return dirname(path.substring(0, i));\n    else\n        return path.substring(0, i).replace(/\\/|\\\\/g, exports.Separator);\n}\nexports.dirname = dirname;\nfunction basename(filename, extname) {\n    if (extname === void 0) { extname = \"\"; }\n    var dir = dirname(filename), basename = (dir == \".\" && filename.match(/^\\.[\\/\\\\]/) == null)\n        ? filename : filename.substring(dir.length + 1);\n    if (extname) {\n        var i = basename.lastIndexOf(extname);\n        basename = i >= 0 ? basename.substring(0, i) : basename;\n    }\n    return basename;\n}\nexports.basename = basename;\nfunction extname(filename) {\n    var baseName = basename(filename), i = baseName.lastIndexOf(\".\");\n    return i >= 0 ? baseName.substring(i) : \"\";\n}\nexports.extname = extname;\nfunction normalizePath(path) {\n    var parts = path.split(/\\/|\\\\/);\n    for (var i = 0; i < parts.length; i++) {\n        if (parts[i] == \"..\") {\n            parts.splice(i - 1, 2);\n            i -= 2;\n        }\n        else if (parts[i] == \".\") {\n            parts.splice(i, 1);\n            i -= 1;\n        }\n    }\n    return parts.join(exports.Separator);\n}\nexports.normalizePath = normalizePath;\nfunction getCwd() {\n    if (exports.IsBrowser) {\n        return location.protocol + \"//\" + location.host\n            + dirname(location.pathname);\n    }\n    else {\n        return process.cwd();\n    }\n}\nexports.getCwd = getCwd;\nfunction isAbsPath(path) {\n    return path[0] == \"/\" || /^[a-zA-Z]:[\\/\\\\]/.test(path);\n}\nexports.isAbsPath = isAbsPath;\nfunction getAbsPath(filename) {\n    if (!isAbsPath(filename)) {\n        var dir = getCwd(), noSep = dir[dir.length - 1] == \"/\";\n        filename = dir + (noSep ? \"\" : exports.Separator) + filename;\n    }\n    return normalizePath(filename);\n}\nexports.getAbsPath = getAbsPath;\nfunction getObjectValues(obj) {\n    var res = [];\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop))\n            res.push(obj[prop]);\n    }\n    return res;\n}\nexports.getObjectValues = getObjectValues;\nfunction getFunctionBodyOffset(fn) {\n    var fnStr = fn.toString(), i = fnStr.indexOf(\"{\") + 1, defArr = fnStr.slice(0, i).split(\"\\n\"), inNewLine = fnStr[i] == \"\\n\", column = inNewLine ? 0 : defArr[defArr.length - 1].indexOf(\"{\") + 2, line = inNewLine ? defArr.length : defArr.length - 1;\n    return { line: line, column: column };\n}\nexports.getFunctionBodyOffset = getFunctionBodyOffset;\n//# sourceMappingURL=util.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar UnclosedTagError = (function (_super) {\n    __extends(UnclosedTagError, _super);\n    function UnclosedTagError(message, filename, line, column) {\n        var _this = _super.call(this, message) || this;\n        _this.filename = filename;\n        _this.line = line;\n        _this.column = column;\n        return _this;\n    }\n    return UnclosedTagError;\n}(SyntaxError));\nexports.UnclosedTagError = UnclosedTagError;\n//# sourceMappingURL=errors.js.map","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./errors\"));\n__export(require(\"./parser\"));\n__export(require(\"./util\"));\n//# sourceMappingURL=index.js.map","module.exports = require(\"fs\");","import {\n    normalizePath,\n    dirname,\n    isAbsPath,\n    escape,\n    getObjectValues,\n    getFunctionBodyOffset,\n    Node\n} from \"whatstpl-toolkit\";\n\nexport interface SourceMap {\n    [line: string]: {\n        column: number;\n        node: Node;\n    }\n}\n\nexport class Module {\n    id: string;\n    filename: string;\n    dirname: string;\n    code: string;\n    parent: Module;\n    children: { [filename: string]: Module } = {};\n    sourceMap: SourceMap = {};\n\n    static cache: { [filename: string]: Module } = {};\n    static sourceMaps: { [filename: string]: SourceMap } = {};\n\n    constructor(filename: string) {\n        this.id = this.filename = normalizePath(filename);\n        this.dirname = dirname(filename);\n        this.code = \"\";\n    }\n\n    /**\n     * \n     * @param id Module id, usually it's the module filename.\n     * @param locals Local variables passed to the module.\n     * @param contents Layout contents, used when the current module is a \n     *  layout module.\n     */\n    require(id: string, locals: { [name: string]: any } = {}, contents = \"\"): {\n        [name: string]: any;\n        default?: string;\n    } {\n        let filename = isAbsPath(id) || this.dirname == \".\"\n            ? id\n            : normalizePath(this.dirname + \"/\" + id);\n        let dir = dirname(filename);\n\n        if (Module.cache[filename]) {\n            let _module = Module.cache[filename],\n                _exports = { default: \"\" },\n                _require = (id: string, locals = {}, contents = \"\") => {\n                    return _module.require(id, locals, contents);\n                };\n\n            this.children[filename] = _module;\n\n            let fn = createFunction(this.filename, _module.code, locals);\n\n            fn.call(\n                _exports,\n                _require,\n                filename,\n                dir,\n                contents,\n                locals,\n                escape,\n                ...getObjectValues(locals)\n            );\n\n            return _exports;\n        } else {\n            throw new Error(\"the request module hasn't been imported!\");\n        }\n    }\n}\n\nconst Params = \"require, __filename, __dirname, __contents, __locals, __escape\";\nconst EvalRE = /at ([a-zA-Z0-9_\\.]+) \\(eval at.+<anonymous>:(\\d+:\\d+)\\)/;\nconst RequireRE = /const __module_\\d+ = require\\('(.+?)'/;\nconst FnCallRE = /([a-zA-Z0-9_]+).call\\(this.*\\)/;\n\n// The `new Function()` will generate a function which it's string \n// representation is different in different JavaScript engines, so here I \n// calculate out the function body offset from a test function, so that when \n// replacing the error, the program can calculate the accurate position of the\n// function body.\nconst FnBodyOffset = getFunctionBodyOffset(new Function(\"a, b\", \"a + b\"));\n\nfunction createFunction(filename: string, code: string, locals: {\n    [prop: string]: any\n}) {\n    let props = Object.keys(locals).join(\", \");\n\n    try {\n        return new Function(Params + (props ? \", \" + props : \"\"), code);\n    } catch (err) {\n        if (err instanceof SyntaxError) { // replace the error stack.\n            if (filename && filename !== \"undefined\") {\n                let stacks = err.stack.split(\"\\n\");\n                stacks[1] = stacks[1].replace(/<anonymous>|Function \\(native\\)/, filename);\n                err.stack = stacks.join(\"\\n\");\n            }\n\n            throw err;\n        } else {\n            throw replaceError(err, filename);\n        }\n    }\n}\n\n/** Gets the function name from a line of code. */\nfunction getFuncName(lineCode: string): string {\n    let matches = lineCode.match(FnCallRE);\n    return matches ? matches[1] : \"\";\n}\n\n/** Gets the imported filename from a `require()` statement. */\nfunction getImportFilename(code: string, line: number): string {\n    let codeArr = code.split(\"\\n\"),\n        funcName = getFuncName(codeArr[line - 1]),\n        lineCode: string, matches: RegExpMatchArray;\n\n    if (funcName) {\n        let re = new RegExp(`const ${funcName} = (__module_\\\\d+)\\.`),\n            _codeArr: string[], moduleId: string;\n\n        for (let i in codeArr) {\n            matches = codeArr[i].match(re);\n\n            if (matches) {\n                _codeArr = codeArr.slice(0, parseInt(i));\n                moduleId = matches[1];\n\n                break;\n            }\n        }\n\n        if (moduleId && _codeArr && _codeArr.length) {\n            _codeArr.reverse();\n            let re = new RegExp(`const ${moduleId} = require\\\\('(.+?)'`);\n\n            for (let code of _codeArr) {\n                matches = code.match(re);\n\n                if (matches)\n                    return matches[1].replace(/\\\\\\\\/g, \"\\\\\");\n            }\n        } else {\n            return \"\";\n        }\n    } else {\n        // line number starts from 1, while array index starts from 0, so here \n        // must decrease 1.\n        lineCode = codeArr[line - 1];\n        matches = lineCode && lineCode.match(RequireRE);\n\n        return matches ? matches[1].replace(/\\\\\\\\/g, \"\\\\\") : \"\";\n    }\n}\n\n/**\n * Replaces error stack according to the source map.\n * @param filename The main module filename.\n */\nexport function replaceError(err: Error, filename: string): Error {\n    let stacks = err.stack.split(\"\\n\").reverse();\n\n    for (let i in stacks) {\n        // first line the the stack or failed to parse the filename.\n        if (stacks[i][0] != \" \" || !filename) continue;\n\n        let matches = stacks[i].match(EvalRE);\n\n        if (matches) {\n            let funcName = matches[1],\n                pair = matches[2].split(\":\"),\n                line: number = parseInt(pair[0]),\n                column: number = parseInt(pair[1]),\n                // The running code will be wrapped in a function which the \n                // definition takes at least one line, so here the line number \n                // should decrease according to the function body offset.\n                source = {\n                    funcName,\n                    filename,\n                    line: line - FnBodyOffset.line,\n                    column\n                },\n                /** The source map of one line of code. */\n                map = Module.sourceMaps[filename][source.line],\n                code = Module.cache[filename].code;\n\n            // If the source line is 1 (the first line), then the column \n            // should be calculated as well.\n            if (source.line == 1)\n                source.column = column - FnBodyOffset.column;\n\n            // recalculate the filename, move to the next import file.\n            filename = getImportFilename(code, source.line);\n\n            // Replace the line number to the line number in the source file.\n            source.line = map.node.line;\n            // Calculate and replace the column number.\n            source.column = (column - map.column) + map.node.column;\n\n            stacks[i] = `    at ${source.funcName} (${source.filename}`\n                + `:${source.line}:${source.column})`;\n        }\n    }\n\n    // Regenerate the error stack.\n    stacks.reverse();\n    err.stack = stacks.join(\"\\n\");\n\n    return err;\n}","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar errors_1 = require(\"./errors\");\nvar util_1 = require(\"./util\");\nvar AttrRe = /([0-9a-zA-Z:\\-]+)\\s*=\\s*|([0-9a-zA-Z:\\-]+)\\s*/;\nvar Parser = (function () {\n    function Parser(filename) {\n        if (filename === void 0) { filename = \"\"; }\n        var _this = this;\n        this.listeners = {};\n        this.outputTags = Parser.OutputTags;\n        this.blockTags = Parser.BlockTags;\n        if (filename)\n            this.filename = util_1.getAbsPath(filename);\n        else\n            this.filename = \"undefined\";\n        this.renewRegExp();\n        this.on(\"block\", function (node) {\n            var attrs = node.attributes;\n            if (node.tag == \"block\") {\n                _this.blockTags.push(attrs.name.value);\n                _this.renewRegExp();\n            }\n            else if (node.tag == \"import\" && attrs.target && attrs.target.value) {\n                var tags = attrs.target.value.split(/,\\s*/);\n                for (var i in tags) {\n                    var pair = tags[i].split(/\\s+as\\s+/);\n                    tags[i] = pair[1] || pair[0];\n                }\n                _this.blockTags = _this.blockTags.concat(tags);\n                _this.renewRegExp();\n            }\n        });\n    }\n    Parser.prototype.renewRegExp = function () {\n        var tagStr = this.blockTags.join(\"|\");\n        var pattern = \"<!--(.*?)-->|<!--(.*)|(\"\n            + this.outputTags.join(\"|\")\n            + \")\\{(.+?)\\}|<(\"\n            + tagStr\n            + \")[\\\\s|\\\\/|>]|<\\\\/(\"\n            + tagStr\n            + \")>\";\n        this.regexp = new RegExp(pattern);\n    };\n    Parser.prototype.on = function (event, listener) {\n        if (!this.listeners[event])\n            this.listeners[event] = [];\n        this.listeners[event].push(listener);\n    };\n    Parser.prototype.emit = function (event) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        if (!this.listeners[event] || !this.listeners[event].length)\n            return false;\n        for (var _a = 0, _b = this.listeners[event]; _a < _b.length; _a++) {\n            var listener = _b[_a];\n            listener.apply(void 0, args);\n        }\n        return true;\n    };\n    Parser.prototype.parse = function (html) {\n        var root = {\n            tag: \"root\",\n            type: \"root\",\n            line: 1,\n            column: 1,\n            contents: [],\n            closed: false\n        };\n        this.html = html.trimRight().replace(/\\r\\n|\\r/g, \"\\n\");\n        this.parseHtml(this.html, 1, 1, root);\n        return root;\n    };\n    Parser.prototype.getLine = function (html, line) {\n        var lineStr, left;\n        while (true) {\n            var end = html.indexOf(\"\\n\");\n            lineStr = (end >= 0 ? html.substring(0, end) : html).trimRight();\n            left = end >= 0 ? html.substring(end + 1) : \"\";\n            if (lineStr || !left) {\n                break;\n            }\n            else {\n                line += 1;\n                html = left;\n            }\n        }\n        return { lineStr: lineStr, left: left, line: line };\n    };\n    Parser.prototype.attachTextNode = function (lineStr, line, column, endIndex, nodes, keepPureSpaces) {\n        if (keepPureSpaces === void 0) { keepPureSpaces = false; }\n        var textNode = {\n            type: \"text\",\n            line: line,\n            column: column,\n            contents: endIndex ? lineStr.substring(0, endIndex) : lineStr + \"\\n\",\n            closed: true,\n        };\n        if (keepPureSpaces || textNode.contents.trimLeft()) {\n            nodes.push(textNode);\n            this.emit(\"text\", textNode);\n        }\n    };\n    Parser.prototype.parseHtml = function (html, line, column, parent) {\n        if (column === void 0) { column = 1; }\n        var LineInfo = this.getLine(html, line), lineStr = LineInfo.lineStr, matches = lineStr.match(this.regexp), nodes = parent.contents;\n        html = LineInfo.left;\n        line = LineInfo.line;\n        if (!matches) {\n            if (parent.tag == \"script\"\n                && parent.attributes.engine\n                && parent.attributes.engine.value == Parser.EngineName) {\n                var snippetNode = {\n                    type: \"snippet\",\n                    line: line,\n                    column: column,\n                    contents: lineStr + \"\\n\",\n                    closed: true,\n                };\n                nodes.push(snippetNode);\n                this.emit(\"snippet\", snippetNode);\n            }\n            else {\n                this.attachTextNode(lineStr, line, column, NaN, nodes);\n            }\n            line += 1;\n            column = 1;\n        }\n        else if (matches[1] && parent.tag != \"script\") {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n            var left = lineStr.substring(matches.index + matches[0].length), commentNode = {\n                type: \"comment\",\n                line: line,\n                column: column,\n                contents: matches[0],\n                closed: false\n            };\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n            if (left) {\n                html = left + \"\\n\" + html;\n                column += matches[0].length;\n            }\n            else {\n                commentNode.contents += \"\\n\";\n                line += 1;\n                column = 1;\n            }\n        }\n        else if (matches[2] && parent.tag != \"script\") {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n            var commentNode = {\n                type: \"comment\",\n                line: line,\n                column: column,\n                contents: lineStr.substring(matches.index),\n                closed: false\n            };\n            line += 1;\n            column = 1;\n            var res = this.parseComment(html, line, column, commentNode);\n            nodes.push(commentNode);\n            this.emit(\"comment\", commentNode);\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        }\n        else if (matches[3] && matches[4]) {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes, matches[3] != \"!\");\n                column += matches.index;\n            }\n            column += 2;\n            var varNode = {\n                tag: matches[3],\n                type: \"var\",\n                line: line,\n                column: column,\n                contents: matches[4],\n                closed: true,\n            };\n            nodes.push(varNode);\n            this.emit(\"var\", varNode);\n            var endColumn = matches.index + matches[4].length + 3, left = lineStr.substring(endColumn);\n            if (left.trimRight()) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[4].length + 1;\n            }\n            else {\n                line += 1;\n                column = 1;\n            }\n        }\n        else if (matches[5] && parent.tag != \"script\") {\n            if (matches.index) {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n                column += matches.index;\n            }\n            var endColumn = matches.index + matches[0].length, ending = lineStr[endColumn - 1], tagClosed = ending == \"/\" || ending == \">\", blockNode = {\n                tag: matches[5],\n                type: \"block\",\n                line: line,\n                column: column,\n                attributes: {},\n                contents: [],\n                closed: false,\n            };\n            if (tagClosed)\n                endColumn -= 1;\n            var left = lineStr.substring(endColumn);\n            if (!left && html) {\n                column = 1;\n                var LineInfo_1 = this.getLine(html, line);\n                if (LineInfo_1.lineStr) {\n                    left = LineInfo_1.lineStr;\n                    html = LineInfo_1.left;\n                }\n            }\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += matches[0].length;\n                if (tagClosed)\n                    column -= 1;\n            }\n            else {\n                throw new errors_1.UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            }\n            var res = this.applyAttr(html, line, column, blockNode.attributes);\n            blockNode.closed = res.blockClosed;\n            if (res.left && !blockNode.closed) {\n                res = this.parseHtml(res.left, res.line, res.column, blockNode);\n            }\n            nodes.push(blockNode);\n            this.emit(\"block\", blockNode);\n            html = res.left;\n            line = res.line;\n            column = res.column;\n        }\n        else if (matches[6] && matches[6] == parent.tag) {\n            if (matches.index && parent.tag != \"script\") {\n                this.attachTextNode(lineStr, line, column, matches.index, nodes);\n            }\n            parent.closed = true;\n            var endColumn = matches.index + matches[0].length, left = lineStr.substring(endColumn);\n            if (left) {\n                html = left + (html ? \"\\n\" + html : \"\");\n                column += endColumn;\n            }\n            else {\n                line += 1;\n                column = 1;\n            }\n        }\n        else {\n            this.attachTextNode(lineStr, line, column, NaN, nodes);\n            line += 1;\n            column = 1;\n        }\n        if (html && !parent.closed) {\n            return this.parseHtml(html, line, column, parent);\n        }\n        else {\n            parent.closed = true;\n            return { line: line, column: column, left: html };\n        }\n    };\n    Parser.prototype.applyAttr = function (html, line, column, attrs) {\n        var LineInfo = this.getLine(html, line), lineStr = LineInfo.lineStr, leading = lineStr.trimLeft()[0], tagClosed = leading == \"/\" || leading == \">\", matches = tagClosed ? null : lineStr.match(AttrRe);\n        line = LineInfo.line;\n        html = LineInfo.left;\n        if (!matches) {\n            var i = lineStr.indexOf(\">\");\n            if (i === -1) {\n                throw new errors_1.UnclosedTagError(\"unclosed tag\", this.filename, line, column);\n            }\n            else {\n                column += i + 1;\n                var left_1 = lineStr.substring(i + 1);\n                if (left_1) {\n                    html = left_1 + \"\\n\" + html;\n                }\n                else {\n                    line += 1;\n                    column = 1;\n                }\n            }\n            return {\n                line: line,\n                column: column,\n                left: html,\n                blockClosed: leading == \"/\"\n            };\n        }\n        var name;\n        var value;\n        var quoted = true;\n        var left;\n        if (matches[1]) {\n            var pos = matches.index + matches[0].length, quote = lineStr[pos], end = void 0;\n            quoted = quote == \"'\" || quote == '\"';\n            if (quoted)\n                pos += 1;\n            if (quoted) {\n                end = lineStr.indexOf(quote, pos);\n            }\n            else {\n                end = lineStr.indexOf(\"/\", pos);\n                if (end === -1)\n                    end = lineStr.indexOf(\">\", pos);\n            }\n            name = matches[1],\n                value = end === -1 ? \"\" : lineStr.substring(pos, end);\n            left = lineStr.substring(end + 1);\n            column += pos;\n        }\n        else if (matches[2]) {\n            name = value = matches[2].trim();\n            left = lineStr.substring(matches.index + matches[0].length);\n            column += matches.index;\n        }\n        attrs[name] = { name: name, value: value, line: line, column: column };\n        if (left) {\n            html = left + \"\\n\" + html;\n            column += (matches[1] ? value.length : matches[0].length);\n            column += (quoted ? 1 : 0);\n        }\n        else {\n            line += 1;\n            column = 1;\n        }\n        return this.applyAttr(html, line, column, attrs);\n    };\n    Parser.prototype.parseComment = function (html, line, column, commentNode) {\n        var LineInfo = this.getLine(html, line), lineStr = LineInfo.lineStr, matches = lineStr && lineStr.match(/-->/);\n        line = LineInfo.line;\n        html = LineInfo.left;\n        if (lineStr)\n            commentNode.contents += \"\\n\";\n        if (!matches) {\n            commentNode.contents += lineStr;\n            line += 1;\n            column = 1;\n            if (html) {\n                return this.parseComment(html, line, column, commentNode);\n            }\n            else {\n                return { line: line, column: column, left: html };\n            }\n        }\n        else {\n            if (matches.index) {\n                commentNode.contents += lineStr.substring(0, matches.index);\n            }\n            commentNode.contents += matches[0];\n            commentNode.closed = true;\n            column += matches.index + 3;\n            var left = lineStr.substring(column);\n            if (left) {\n                html = left + \"\\n\" + html;\n            }\n            else {\n                line += 1;\n                column = 1;\n            }\n        }\n        return { line: line, column: column, left: html };\n    };\n    Parser.EngineName = \"whatstpl\";\n    Parser.BlockTags = [\n        \"layout\",\n        \"import\",\n        \"export\",\n        \"block\",\n        \"if\",\n        \"else-if\",\n        \"else\",\n        \"switch\",\n        \"case\",\n        \"default\",\n        \"for\",\n        \"while\",\n        \"do\",\n        \"continue\",\n        \"break\",\n        \"script\",\n    ];\n    Parser.OutputTags = [\n        \"!\",\n        \"@\",\n        \"#\",\n    ];\n    return Parser;\n}());\nexports.Parser = Parser;\n//# sourceMappingURL=parser.js.map","import {\n    Node,\n    Parser,\n    isAbsPath,\n    extname,\n    dirname,\n    normalizePath,\n    getAbsPath,\n    getCwd,\n    Separator,\n    IsBrowser\n} from \"whatstpl-toolkit\";\nimport assign = require(\"object-assign\");\nimport { Module, replaceError } from \"./module\";\n\nvar fs: {\n    readFile(filename: string, encoding: string, cb: (err: Error, data: string) => void);\n} = null;\n\nif (!IsBrowser) {\n    fs = require(\"fs\");\n}\n\nexport type Variables = { [name: string]: any };\nexport type Renderer = (locals?: Variables) => string;\n\nexport interface CompileOption {\n    /** For fs.readFile() to decode the file contents. */\n    encoding?: string;\n    /** Whether the compiled function should be cached in memory. */\n    cache?: boolean;\n    /** Whether or not to remove the comments when render HTML. */\n    removeComments?: boolean;\n    /**\n     * Request timeout, used when the program is run in a browser and load \n     * remote template via Ajax.\n     */\n    timeout?: number;\n    /**\n     * Whether or not to send credentials (e.g. cookies) when request, used \n     * when the program is run in a browser and load remote template via Ajax.\n     */\n    withCredentials?: boolean;\n    /**\n     * Request headers, used when the program is run in a browser and load \n     * remote template via Ajax.\n     */\n    headers?: { [name: string]: string | number | boolean | string[] };\n}\n\nexport const CompileOption: CompileOption = {\n    encoding: \"utf8\",\n    cache: false,\n    removeComments: false,\n    timeout: 5000,\n    withCredentials: false,\n    headers: null\n}\n\nexport class Template {\n    filename: string;\n    options: CompileOption;\n    module: Module;\n\n    private currentLine: number = 0;\n    private importedModuleCount: number = 0;\n    private layouts: Array<{ filename: string, node: Node }> = [];\n\n    static cache: { [filename: string]: Renderer } = {};\n\n    constructor(filename?: string, encoding?: string);\n    constructor(filename?: string, options?: CompileOption);\n    constructor(filename = \"\", options: any = \"utf8\") {\n        if (filename)\n            this.filename = getAbsPath(filename);\n        else\n            this.filename = \"undefined\";\n\n        if (typeof options == \"string\")\n            options = { encoding: options };\n\n        this.options = assign({}, CompileOption, options);\n    }\n\n    /** Renders the given template contents. */\n    async render(tpl: string, locals: Variables = {}): Promise<string> {\n        let render = await this.compile(tpl);\n        return render(locals);\n    }\n\n    /** Renders the given file. */\n    static async renderFile(filename?: string, locals?: Variables, encoding?: string): Promise<string>;\n    static async renderFile(filename?: string, locals?: Variables, options?: CompileOption): Promise<string>;\n    static async renderFile(filename: string, locals: Variables = null, options = null): Promise<string> {\n        let render = await this.compileFile(filename, options);\n        return render(locals || {});\n    }\n\n    /** Compiles the given template contents. */\n    async compile(tpl: string): Promise<Renderer> {\n        // If the function is already cached, retrieve it instead.\n        if (this.options.cache && Template.cache[this.filename]) {\n            return Template.cache[this.filename];\n        }\n\n        let parser = new Parser(this.filename),\n            node: Node = parser.parse(tpl),\n            _module: Module = await this.createModule(node);\n\n        // Wrap the function in a render function, so when it is  called, the \n        // program can catch and re-throw any errors, and only  return the \n        // `default` property (HTML) from the module.\n        let render: Renderer = (locals = {}) => {\n            try {\n                return _module.require(this.filename, locals).default.trimRight();\n            } catch (err) { // replace and re-throw the error.\n                throw replaceError(err, this.filename);\n            }\n        };\n\n        if (this.options.cache)\n            Template.cache[this.filename] = render;\n\n        return render;\n    }\n\n    /** Compiles the given file. */\n    static async compileFile(filename: string, encoding?: string): Promise<Renderer>;\n    static async compileFile(filename: string, options?: CompileOption): Promise<Renderer>;\n    static async compileFile(filename: string, options: any = null): Promise<Renderer> {\n        filename = getAbsPath(filename);\n\n        // If the function is already cached, retrieve it instead.\n        if (options && options.cache && Template.cache[filename]) {\n            return Template.cache[filename];\n        }\n\n        let tpl: Template = new this(filename, options),\n            html = await tpl.loadTemplate();\n\n        return tpl.compile(html);\n    }\n\n    /**\n     * Registers the given template string as a template, and set a temporary\n     * filename for importing usage.\n     */\n    static register(filename: string, tpl: string): Promise<Renderer> {\n        let tplObj = new this(filename, {\n            cache: true\n        });\n\n        return tplObj.compile(tpl);\n    }\n\n    /** Loads the template contents from the file. */\n    protected loadTemplate(): Promise<string> {\n        if (!IsBrowser) {\n            return new Promise((resolve, reject) => {\n                fs.readFile(this.filename, this.options.encoding, (err, data) => {\n                    err ? reject(err) : resolve(data);\n                });\n            });\n        } else {\n            return new Promise((resolve, reject) => {\n                let xhr = new XMLHttpRequest();\n                xhr.timeout = this.options.timeout;\n                xhr.withCredentials = this.options.withCredentials;\n                xhr.open(\"GET\", this.filename, true);\n\n                if (this.options.headers) {\n                    for (let name in this.options.headers) {\n                        let value: any = this.options.headers[name];\n\n                        if (Array.isArray(value)) {\n                            value = value.join(\", \");\n                        } else if (typeof value != \"string\") {\n                            if (typeof value.toString == \"function\")\n                                value = value.toString();\n                            else\n                                value = String(value);\n                        }\n\n                        xhr.setRequestHeader(name, value);\n                    }\n                }\n\n                xhr.onload = () => {\n                    resolve(xhr.responseText);\n                };\n\n                xhr.onabort = xhr.onerror = xhr.ontimeout = () => {\n                    reject(new Error(\"failed to load remote module.\"));\n                };\n\n                xhr.send();\n            });\n        }\n    }\n\n    /** Gets the absolute path of the filename, if it is relative.  */\n    protected getAbsPath(filename: string): string {\n        if (!isAbsPath(filename)) {\n            let dir = this.filename && this.filename != \"undefined\"\n                ? dirname(this.filename)\n                : getCwd();\n\n            filename = normalizePath(dir + Separator + filename);\n        }\n\n        // If the extension name is omitted, use the one of the parent file.\n        if (!extname(filename)) {\n            filename += extname(this.filename);\n        }\n\n        return filename;\n    }\n\n    /** Adds a line of source map to the internal `sourceMap` property.  */\n    private addSourceMap(column: number, node: Node) {\n        this.currentLine += 1;\n        this.module.sourceMap[this.currentLine] = { column, node };\n    }\n\n    /** Pushes a line of code to the internal `code` object. */\n    protected pushCode(before: string, contents: string, after: string, node: Node, lineEnding = true) {\n        this.module.code += before + contents + after + (lineEnding ? \"\\n\" : \"\");\n        // `length` of a string starts from 0, but column number starts from 1,\n        // so here it should add 1. \n        this.addSourceMap(before.length + 1, node);\n    }\n\n    /** Imports a module from the given file. */\n    protected async importModule(parent: Module = null): Promise<Module> {\n        if (Module.cache[this.filename]) {\n            return Module.cache[this.filename];\n        }\n\n        let tpl = await this.loadTemplate(),\n            parser = new Parser(this.filename),\n            node = parser.parse(tpl);\n\n        return this.createModule(node, parent);\n    }\n\n    /** Creates a new module according to the given filename and node tree. */\n    private async createModule(node: Node, parent: Module = null): Promise<Module> {\n        let _module = new Module(this.filename);\n\n        this.module = _module;\n\n        await this.attachBlockContents(node);\n\n        // If there is any layouts, push then to the very bottom of the \n        // compiled code, and in the layout module, use variable `__contents` \n        // to  attach the inner contents.\n        if (this.layouts.length) {\n            for (let { filename, node } of this.layouts) {\n                this.importedModuleCount += 1;\n\n                let moduleId = \"__module_\" + this.importedModuleCount;\n                filename = filename.replace(/\\\\/g, \"\\\\\\\\\");\n\n                // When dealing with layout, only import the `default` property,\n                // and reassign the `default` in the current module.\n                this.pushCode(\n                    `const ${moduleId} = `,\n                    `require('${filename}', __locals, this.default)`,\n                    \";\",\n                    node\n                );\n                this.pushCode(\"this.default = \", `${moduleId}.default`, \";\", node);\n            }\n        }\n\n        _module.parent = parent;\n        Module.cache[this.filename] = _module; // cache the module.\n        Module.sourceMaps[this.filename] = _module.sourceMap; // cache the source map.\n\n        return _module;\n    }\n\n    /** Attaches block contents to the internal `code` object. */\n    private async attachBlockContents(parent: Node, indent = \"\") {\n        let cutSpace = NaN;\n\n        for (let node of <Node[]>parent.contents) {\n            if (node.type == \"text\"\n                || (node.type == \"comment\" && !this.options.removeComments)) {\n                let contents = (<string>node.contents).replace(/\\n/g, \"\\\\n\")\n                    .replace(/'/g, \"\\\\'\");\n\n                this.pushCode(\n                    indent + \"this.default += '\",\n                    contents,\n                    \"';\",\n                    node\n                );\n            } else if (node.type == \"var\") {\n                if (node.tag == \"!\") { // !{statement}\n                    this.pushCode(indent, <string>node.contents, \";\", node);\n                } else if (node.tag == \"@\") { // @{statement}\n                    this.pushCode(\n                        indent + \"this.default += \",\n                        <string>node.contents,\n                        \";\",\n                        node\n                    );\n                } else { // #{statement}\n                    this.pushCode(\n                        indent + \"this.default += __escape(\",\n                        <string>node.contents,\n                        \");\",\n                        node\n                    );\n                }\n            } else if (node.type == \"snippet\") { // <script engine=\"whatstpl\"></script>\n                // if (isNaN(cutSpace)) {\n                //     let match = (<string>node.contents).match(/\\S/);\n\n                //     if (match)\n                //         cutSpace = match.index;\n                // }\n\n                let contents: string = cutSpace\n                    ? (<string>node.contents).substring(cutSpace)\n                    : <string>node.contents;\n\n                this.pushCode(indent.substring(4), contents, \"\", node, false);\n            } else if (node.type == \"block\") {\n                if (node.tag == \"import\") { // <import/>\n                    await this.attachImport(node, indent);\n                } else if (node.tag == \"export\") { // <export/>\n                    await this.attachExport(node, indent);\n                } else if (node.tag == \"block\") { // <block></block>\n                    await this.attackBlock(node, indent);\n                } else if (node.tag == \"if\") { // <if></if>\n                    await this.attachIf(node, indent);\n                } else if (node.tag == \"else-if\") { // <else-if></else-if>\n                    await this.attachElseIf(node, indent.substring(4));\n                } else if (node.tag == \"else\") { // <else></else>\n                    await this.attachElse(node, indent.substring(4));\n                } else if (node.tag == \"switch\") { // <switch></switch>\n                    await this.attachSwitch(node, indent);\n                } else if (node.tag == \"case\") { // <case></case>\n                    await this.attachCase(node, indent);\n                } else if (node.tag == \"default\") { // <default></default>\n                    await this.attachDefault(node, indent);\n                } else if (node.tag == \"for\") { // <for></for>\n                    await this.attachFor(node, indent);\n                } else if (node.tag == \"while\") { // <while></while>\n                    await this.attachWhile(node, indent);\n                } else if (node.tag == \"do\") { // <do></do>\n                    await this.attachDoWhile(node, indent);\n                } else if (node.tag == \"continue\" || node.tag == \"break\") {\n                    // <continue/> and <break/>\n                    this.pushCode(indent, node.tag, \";\", node);\n                } else if (node.tag == \"layout\") { // <layout></layout>\n                    await this.attachLayout(node);\n                } else if (node.tag == \"script\") { // <script></script>\n                    let attrs = node.attributes;\n                    let shouldCompile = !attrs.engine\n                        || attrs.engine.value != Parser.EngineName;\n\n                    if (shouldCompile) { // JavaScript of the HTML.\n                        let contents = \"<script\";\n\n                        // attach attributes.\n                        for (let name in attrs) {\n                            contents += ` ${name}=\"${attrs[name].value}\"`;\n                        }\n\n                        contents += \">\\\\n\";\n                        this.pushCode(\n                            indent + \"this.default += '\",\n                            contents,\n                            \"';\",\n                            node\n                        );\n                    }\n\n                    // Attaches the contents in the <script> element.\n                    await this.attachBlockContents(node, indent + \"    \");\n\n                    if (shouldCompile) {\n                        this.pushCode(\n                            indent + \"this.default += '\",\n                            \"</script>\\\\n\",\n                            \"';\",\n                            node\n                        );\n                    }\n                } else { // user-defined block tags.\n                    let name = node.tag.replace(/-/g, \"_\"),\n                        attrs = node.attributes;\n\n                    if (attrs.await && attrs.await.value != \"false\")\n                        name = \"await \" + name;\n\n                    let contents = \"call(this\";\n\n                    // User-defined block tags are treated as function, when \n                    // called, the attribute `data` will be used as arguments\n                    // and passed to the function.\n                    if (attrs.data && attrs.data.value)\n                        contents += \", \" + attrs.data.value;\n\n                    contents += \")\";\n\n                    this.pushCode(indent + name + \".\", contents, \";\", node);\n                }\n            }\n        }\n    }\n\n    /** <layout file=\"<filename>\"/> */\n    private async attachLayout(node: Node) {\n        let filename = this.getAbsPath(node.attributes.file.value),\n            tpl: Template = new (<any>this.constructor)(filename, this.options);\n\n        await tpl.importModule(this.module);\n\n        // The layouts are not attached immediately, they will be stored in \n        // an array, when the current module is compiled, layouts will be \n        // added to the very end of the compiled code.\n        this.layouts.push({ filename, node });\n    }\n\n    /** <import[ target=\"<block-name>\"] file|from=\"<filename>\"/> */\n    private async attachImport(node: Node, indent = \"\") {\n        let attrs = node.attributes,\n            filename = this.getAbsPath(attrs.from ? attrs.from.value : attrs.file.value),\n            tpl: Template = new (<any>this.constructor)(filename, this.options);\n\n        await tpl.importModule(this.module);\n\n        this.importedModuleCount += 1;\n\n        let moduleId = \"__module_\" + this.importedModuleCount;\n        filename = filename.replace(/\\\\/g, \"\\\\\\\\\");\n        this.pushCode(\n            `${indent}const ${moduleId} = `,\n            `require('${filename}', __locals)`,\n            \";\",\n            node\n        );\n\n        // The 'target' attribute in a <import/> elements sets which names \n        // should be imported.\n        if (attrs.target && attrs.target.value) {\n            let tags = attrs.target.value.replace(/-/g, \"_\").split(/\\s*,\\s*/);\n\n            for (let tag of tags) {\n                // parse as syntax.\n                let pair = tag.split(/\\s*as\\s*/),\n                    oldName = pair[0],\n                    newName = pair[1] || oldName;\n\n                this.pushCode(\n                    indent,\n                    `const ${newName} = ${moduleId}.${oldName}`,\n                    \";\",\n                    node\n                );\n            }\n        } else { // If no 'target', then import the `default` property.\n            this.pushCode(indent, `this.default += ${moduleId}.default`, \";\", node);\n        }\n    }\n\n    /** <export target=\"<block-names>\"/> */\n    private async attachExport(node: Node, indent = \"\") {\n        // The 'target' attribute in a <export/> elements sets which names \n        // should be exported and can be imported by other modules.\n        if (node.attributes.target && node.attributes.target.value) {\n            let tags = node.attributes.target.value.split(/,\\s*/);\n\n            for (let i in tags) {\n                // parse `as` syntax\n                let pair = tags[i].split(/\\s+as\\s+/),\n                    oldName = pair[0].replace(/-/g, \"_\"),\n                    newName = pair[1] ? pair[1].replace(/-/g, \"_\") : oldName;\n\n                this.pushCode(indent, `this.${newName} = ${oldName}`, \";\", node);\n            }\n        }\n    }\n\n    /** <block name=\"<name>\"[ export][ async][ params=\"<params>\"]></block> */\n    private async attackBlock(block: Node, indent = \"\") {\n        let attrs = block.attributes,\n            name = attrs.name.value.replace(/-/g, \"_\"),\n            contents = `function ${name}(`;\n\n        // 'async' attribute means the function is an async function.\n        if (attrs.async && attrs.async.value != \"false\")\n            contents = `async ` + contents;\n\n        // 'params' attribute sets function parameters.\n        if (attrs.params && attrs.params.value)\n            contents += attrs.params.value;\n\n        contents += \")\";\n\n        this.pushCode(indent, contents, \" {\", block);\n\n        await this.attachBlockContents(block, indent + \"    \");\n\n        this.pushCode(indent, \"\", \"}\", block);\n\n        // The block can be exported by setting an 'export' attribute.\n        if (attrs.export && attrs.export.value != \"false\")\n            this.pushCode(indent, `this.${name} = ${name}`, \";\", block);\n    }\n\n    /** <if condition=\"<condition>\"></if> */\n    private async attachIf(block: Node, indent = \"\") {\n        this.pushCode(indent + \"if (\", block.attributes.condition.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <else-if condition=\"<condition>\"></else-if> */\n    private async attachElseIf(block: Node, indent = \"\") {\n        this.pushCode(indent + \"} else if (\", block.attributes.condition.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n    }\n\n    /** <else></else> */\n    private async attachElse(block: Node, indent = \"\") {\n        this.pushCode(indent + \"} else {\", \"\", \"\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n    }\n\n    /** <switch target=\"<target>\"></switch> */\n    private async attachSwitch(block: Node, indent = \"\") {\n        this.pushCode(indent + \"switch (\", block.attributes.target.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <case data=\"<data>\"></case> */\n    private async attachCase(block: Node, indent = \"\") {\n        this.pushCode(indent + \"case \", block.attributes.data.value, \":\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent + \"    \", \"break\", \";\", block);\n    }\n\n    /** <default></default> */\n    private async attachDefault(block: Node, indent = \"\") {\n        this.pushCode(indent + \"default\", \"\", \":\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent + \"    \", \"break\", \";\", block);\n    }\n\n    /** <for statement=\"<statement>\"></for> */\n    private async attachFor(block: Node, indent = \"\") {\n        this.pushCode(indent + \"for (\", block.attributes.statement.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <while condition=\"<condition>\"></while> */\n    private async attachWhile(block: Node, indent = \"\") {\n        this.pushCode(indent + \"while (\", block.attributes.condition.value, \") {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent, \"\", \"}\", block);\n    }\n\n    /** <do while=\"<condition>\"></do> */\n    private async attachDoWhile(block: Node, indent = \"\") {\n        this.pushCode(indent + \"do \", \"\", \" {\", block);\n        await this.attachBlockContents(block, indent + \"    \");\n        this.pushCode(indent + \"} while (\", block.attributes.while.value, \");\", block);\n    }\n}\n\nexport default Template;"],"sourceRoot":""}